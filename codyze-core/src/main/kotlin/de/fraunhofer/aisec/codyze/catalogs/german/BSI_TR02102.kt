/*
 * Copyright (c) 2025, Fraunhofer AISEC. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *                    $$$$$$\  $$$$$$$\   $$$$$$\
 *                   $$  __$$\ $$  __$$\ $$  __$$\
 *                   $$ /  \__|$$ |  $$ |$$ /  \__|
 *                   $$ |      $$$$$$$  |$$ |$$$$\
 *                   $$ |      $$  ____/ $$ |\_$$ |
 *                   $$ |  $$\ $$ |      $$ |  $$ |
 *                   \$$$$$   |$$ |      \$$$$$   |
 *                    \______/ \__|       \______/
 *
 */
package de.fraunhofer.aisec.codyze.catalogs.german

import de.fraunhofer.aisec.codyze.catalogs.CryptoCatalog
import de.fraunhofer.aisec.codyze.catalogs.SotaRequirementsCatalog
import de.fraunhofer.aisec.codyze.catalogs.TLSCatalog
import de.fraunhofer.aisec.codyze.catalogs.helpers.*
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Cipher
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HybridCipher
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.KeyDerivationFunction
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.MessageAuthenticationCode
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.SymmetricCipher
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.TransportEncryption
import de.fraunhofer.aisec.cpg.graph.concepts.manualExtensions.*
import de.fraunhofer.aisec.cpg.query.*
import kotlin.apply
import kotlin.collections.all
import kotlin.collections.any
import kotlin.collections.map
import kotlin.collections.plus
import kotlin.collections.toMutableSet
import kotlin.let

/**
 * Checks the following BSI TRs:
 * - [BSI TR 02102-1 version
 *   2025-01](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile&v=13)
 *   regarding cryptographic requirements
 * - [BSI TR 02102-2 version
 *   2025-01](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102-2.pdf?__blob=publicationFile&v=11)
 *   regarding TLS
 */
class BSI_TR02102(override val requirePQC: Boolean = false) :
    SotaRequirementsCatalog(), CryptoCatalog, TLSCatalog {

    context(kdf: KeyDerivationFunction)
    override fun checkKDF(): QueryTree<Boolean> {
        TODO()
    }

    context(signature: Signature)
    override fun checkSignature(): QueryTree<Boolean> {
        return ((if (requirePQC) emptyList<QueryTree<Boolean>>()
            else
                listOf(
                    signature.checkRSASignature(),
                    signature.checkDSASignature(),
                    signature.checkECDSASignature(),
                )) +
                listOf(
                    signature.checkSlhDsa(),
                    signature.checkMlDsa(),
                    signature.checkStatefulHashBasedSignatures(),
                ))
            .mergeWithAny()
            .apply {
                this.stringRepresentation =
                    if (this.value) {
                        "We use a secure signature algorithm"
                    } else {
                        "We do not use a secure signature algorithm."
                    }
            }
    }

    private fun Signature.checkStatefulHashBasedSignatures(): QueryTree<Boolean> {
        if (this is StatefulHashBasedSignature) {
            val schemeOk = this.schemeName IN listOf("XMSS", "XMSS_MT", "LMS", "HSS")
            return schemeOk
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a hash-based signature scheme signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    private fun Signature.checkSlhDsa(): QueryTree<Boolean> {
        if (this is SlhDsaSignature) {
            val slhdsaSignatureOk =
                QueryTree(
                    value = true,
                    stringRepresentation = "SLH-DSA Signatures are ok.",
                    node = this,
                    operator = GenericQueryOperators.EVALUATE,
                )

            val algorithmOk =
                this.algorithmName IN
                    listOf(
                        "SLH-DSA-SHA2-192s",
                        "SLH-DSA-SHAKE-192s",
                        "SLH-DSA-SHA2-192f",
                        "SLH-DSA-SHAKE-192f",
                        "SLH-DSA-SHA2-256s",
                        "SLH-DSA-SHAKE-256s",
                        "SLH-DSA-SHA2-256f",
                        "SLH-DSA-SHAKE-256f",
                    )

            val isHedged = variant eq Variant.Hedged
            val isPure = version eq Version.Pure

            return slhdsaSignatureOk and algorithmOk and isHedged and isPure
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a SLH-DSA signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    private fun Signature.checkMlDsa(): QueryTree<Boolean> {
        if (this is MlDsaSignature) {
            val mldsaSignatureOk =
                QueryTree(
                    value = true,
                    stringRepresentation = "ML-DSA Signatures are ok.",
                    node = this,
                    operator = GenericQueryOperators.EVALUATE,
                )

            val algorithmOk = this.algorithmName IN listOf("ML-DSA-65", "ML-DSA-87")

            val isHedged = variant eq Variant.Hedged
            val isPure = version eq Version.Pure

            return mldsaSignatureOk and algorithmOk and isHedged and isPure
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a SLH-DSA signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    private fun Signature.checkECDSASignature(): QueryTree<Boolean> {
        if (this is ECDSASignature) {
            val ecdsaSignatureOk =
                QueryTree(
                    value = true,
                    stringRepresentation = "ECDSA Signatures are ok.",
                    node = this,
                    operator = GenericQueryOperators.EVALUATE,
                )

            val parameterOk = checkAcceptedECParameter(this, this.parameter)

            val algorithmOk = this.algorithmName IN listOf("ECDSA", "ECKDSA", "ECKCDSA", "ECGDSA")

            val hashFunctionOk =
                hashFunction?.let { with(it) { checkHashFunction() } }
                    ?: QueryTree(
                        value = false,
                        stringRepresentation = "Could not find hash function",
                        node = this,
                        operator = GenericQueryOperators.EVALUATE,
                    )

            return ecdsaSignatureOk and parameterOk and hashFunctionOk and algorithmOk
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a ECDSA signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    private fun Signature.checkDSASignature(): QueryTree<Boolean> {
        if (this is DSASignature) {
            val dsaSignatureOk =
                QueryTree(
                    value = true,
                    stringRepresentation = "DSA Signatures are ok.",
                    node = this,
                    operator = GenericQueryOperators.EVALUATE,
                )

            val pSizeOk = (primePSize ge 3000)
            val qSizeOk = (primeQSize ge 250)
            val hashFunctionOk =
                hashFunction?.let {
                    with(it) { checkHashFunction() } and (it.outputSize ge primeQSize)
                }
                    ?: QueryTree(
                        value = false,
                        stringRepresentation = "Could not find hash function",
                        node = this,
                        operator = GenericQueryOperators.EVALUATE,
                    )

            return dsaSignatureOk and pSizeOk and qSizeOk and hashFunctionOk
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a DSA signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    private fun Signature.checkRSASignature(): QueryTree<Boolean> {
        if (this is RSASignature) {
            val rsaSignatureOk =
                QueryTree(
                    value = true,
                    stringRepresentation = "RSA Signatures are ok.",
                    node = this,
                    operator = GenericQueryOperators.EVALUATE,
                )

            val goodRSA =
                this.rsaCipher?.let { with(it) { checkRSA() } }
                    ?: QueryTree(
                        value = false,
                        stringRepresentation = "Could not find RSA parameters",
                        node = this,
                        operator = GenericQueryOperators.EVALUATE,
                    )

            val goodFormattingScheme =
                this.formattingScheme?.let {
                    val isEmsaPSS = it is EMSA_PSS
                    val isDs2 = it is DS2
                    val isDs3 = it is DS3
                    listOf(
                            QueryTree(
                                value = isEmsaPSS,
                                stringRepresentation =
                                    if (isEmsaPSS) "Formatting scheme EMSA_PSS is ok."
                                    else "It is not formatting scheme EMSA_PSS.",
                                node = this,
                                operator = GenericQueryOperators.EVALUATE,
                            ),
                            QueryTree(
                                value = isDs2,
                                stringRepresentation =
                                    if (isDs2) "Formatting scheme DS2 is ok."
                                    else "It is not formatting scheme DS2.",
                                node = this,
                                operator = GenericQueryOperators.EVALUATE,
                            ),
                            QueryTree(
                                value = isDs3,
                                stringRepresentation =
                                    if (isDs3) "Formatting scheme DS3 is ok."
                                    else "It is not formatting scheme DS3.",
                                node = this,
                                operator = GenericQueryOperators.EVALUATE,
                            ),
                        )
                        .mergeWithAny()
                        .apply {
                            this.stringRepresentation =
                                if (this.value) "We use a good formatting scheme."
                                else "We do not use a good formatting scheme."
                        }
                }
                    ?: QueryTree(
                        value = false,
                        stringRepresentation = "Could not find formatting scheme",
                        node = this,
                        operator = GenericQueryOperators.EVALUATE,
                    )

            return rsaSignatureOk and goodRSA and goodFormattingScheme
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a RSA signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    fun MessageAuthenticationCode.checkCmac(): QueryTree<Boolean> {
        if (this is CMAC) {
            // CMAC requires a secure block cipher
            return QueryTree(
                value = true,
                stringRepresentation = "CMACs are ok.",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            ) and
                ((this.cipher as? SymmetricCipher)?.let { with(it) { checkSymmetricEncryption() } }
                    ?: QueryTree(
                        false,
                        stringRepresentation = "Could not find symmetric cipher for CMAC",
                        node = this,
                        operator = GenericQueryOperators.EVALUATE,
                    ))
        }
        return QueryTree(
            value = false,
            stringRepresentation = "Not a CMAC signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    fun MessageAuthenticationCode.checkGmac(): QueryTree<Boolean> {
        if (this is GMAC) {
            // GMAC requires a secure block cipher
            return QueryTree(
                value = true,
                stringRepresentation = "GMACs are ok.",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            ) and
                ((this.cipher as? SymmetricCipher)?.let { with(it) { checkSymmetricEncryption() } }
                    ?: QueryTree(
                        false,
                        stringRepresentation = "Could not find symmetric cipher for GMAC",
                        node = this,
                        operator = GenericQueryOperators.EVALUATE,
                    ))
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a GMAC signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    fun MessageAuthenticationCode.checkHmac(): QueryTree<Boolean> {
        if (this is HMAC) {
            // HMAC requires secure hash function
            return QueryTree(
                value = true,
                stringRepresentation = "HMACs are ok.",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            ) and
                (this.hashFunction?.let { with(it) { checkHashFunction() } }
                    ?: QueryTree(
                        false,
                        stringRepresentation = "Could not find hash function for HMAC",
                        node = this,
                        operator = GenericQueryOperators.EVALUATE,
                    ))
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a HMAC signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    fun MessageAuthenticationCode.checkKmac(): QueryTree<Boolean> {
        if (this is KMAC) {
            return QueryTree(
                value = true,
                stringRepresentation = "KMACs are ok.",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            ) and
                ((this.strength eq 128) or (this.strength eq 256)) and
                (this.hashFunction?.let { with(it) { checkHashFunction() } }
                    ?: QueryTree(
                        false,
                        stringRepresentation = "Could not find hash function for KMAC",
                        node = this,
                        operator = GenericQueryOperators.EVALUATE,
                    ))
        }

        return QueryTree(
            value = false,
            stringRepresentation = "Not a HMAC signature",
            node = this,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    context(mac: MessageAuthenticationCode)
    override fun checkMAC(): QueryTree<Boolean> {
        return listOf(mac.checkCmac(), mac.checkGmac(), mac.checkHmac(), mac.checkKmac())
            .mergeWithAny()
            .apply {
                this.stringRepresentation =
                    if (this.value) "We use a MAC which fulfils the state-of-the-art."
                    else "We do not use a MAC which fulfils the state-of-the-art."
            }
    }

    context(cipher: Cipher)
    fun checkKeyEncapsulation(): QueryTree<Boolean> {
        return listOf(
                "FrodoKEM-976",
                "FrodoKEM-1344",
                "mceliece460896",
                "mceliece6688128",
                "mceliece8192128",
                "mceliece460896f",
                "mceliece6688128f",
                "mceliece8192128f",
                "ML-KEM-768",
                "ML-KEM-1024",
            )
            .map { accepted -> accepted eq cipher.cipherName }
            .mergeWithAny()
            .apply {
                this.stringRepresentation =
                    if (this.value) "This is a KEM which is considered as post-quantum secure."
                    else "This is not a KEM which is considered as post-quantum secure."
            }
    }

    context(cipher: SymmetricCipher)
    override fun checkSymmetricEncryption(): QueryTree<Boolean> {
        return cipher.checkAES()
    }

    context(cipher: Cipher)
    override fun checkAsymmetricEncryption(): QueryTree<Boolean> {
        if (requirePQC) return emptyList<QueryTree<Boolean>>().mergeWithAny()

        return listOf(cipher.checkRSA(), cipher.checkDLIES(), cipher.checkECIES()).mergeWithAny()
    }

    context(cipher: Cipher)
    override fun checkKeyExchange(): QueryTree<Boolean> {
        if (requirePQC) return checkKeyEncapsulation()

        return cipher.checkDhKeyExchange() or
            cipher.checkEcdhKeyExchange() or
            checkKeyEncapsulation()
    }

    fun Cipher.checkDhKeyExchange(): QueryTree<Boolean> {
        val isDh = this is DHKeyExchange
        val isDhQt =
            QueryTree<Boolean>(
                value = isDh,
                stringRepresentation =
                    if (isDh) {
                        "The key is exchanged with Diffie-Hellman. That's ok."
                    } else {
                        "They key is not exchanged with Diffie-Hellman."
                    },
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        if (isDh) {
            val keySizeOk = this.keySize?.let { it > 3000 } ?: false
            return isDhQt and
                QueryTree<Boolean>(
                    value = keySizeOk,
                    stringRepresentation =
                        if (keySizeOk) {
                            "The key size is $keySize which is big enough."
                        } else
                            "The key size is $keySize which is not big enough. Minimum requirement is 3000 bit.",
                    node = this,
                    operator = GenericQueryOperators.EVALUATE,
                )
        } else return isDhQt
    }

    fun checkAcceptedECParameter(node: Node, parameter: String?): QueryTree<Boolean> {
        return listOf("brainpoolP256r1", "brainpoolP320r1", "brainpoolP348r1", "brainpoolP512r1")
            .map { goodParams -> goodParams eq parameter }
            .mergeWithAny()
            .apply { this.node = node }
    }

    fun Cipher.checkEcdhKeyExchange(): QueryTree<Boolean> {
        val isEcdh = this is ECDHKeyExchange

        val isEcdhQt =
            QueryTree<Boolean>(
                value = isEcdh,
                stringRepresentation =
                    if (isEcdh) {
                        "The key is exchanged with ECDH. That's ok."
                    } else {
                        "They key is not exchanged with ECDH."
                    },
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        if (!isEcdh) {
            return isEcdhQt
        }
        return isEcdhQt and checkAcceptedECParameter(this, this.parameter)
    }

    context(hashFunction: HashFunction)
    override fun checkHashFunction(): QueryTree<Boolean> {
        val secureFunctions =
            listOf(
                SHA_256::class,
                SHA_384::class,
                SHA_512::class,
                SHA_512_256::class,
                SHA3_256::class,
                SHA3_384::class,
                SHA3_512::class,
            )
        val isValid = secureFunctions.any { it.isInstance(hashFunction) }
        return QueryTree(
            value = isValid,
            stringRepresentation =
                if (isValid)
                    "The hash function ${hashFunction.hashFunctionName} is considered secure."
                else
                    "The hash function ${hashFunction.hashFunctionName} is not considered secure. Should be one of ${secureFunctions.map { cls -> cls.simpleName }}.",
            node = hashFunction,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    context(cipher: TransportEncryption)
    override fun checkTLS(): QueryTree<Boolean> {
        return cipher.checkTLS1_2() or cipher.checkTLS1_3()
    }

    // Symmetric encryption algorithms, their modus, and recommended key lengths. There are also
    // requirements on the IV, and interdependencies between accepted key lengths and modus.

    internal fun SymmetricCipher.checkAES(): QueryTree<Boolean> {
        return listOf(checkAesCCM(), checkAesGCM(), checkAesGcmSiv(), checkAesCBC(), checkAesCTR())
            .mergeWithAny(this)
    }

    internal fun SymmetricCipher.checkAesCCM(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CCM")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        // Note: The TR itself has no limitation on the key size for AES-CCM, but it references NIST
        // SP
        // 800-38C, which only defines AES-CCM for key sizes of 128 bits.
        val validKeyLengthCheck = this.validKeyLength(listOf(128))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        // TODO: Not sure why the AI suggests me this value. The TR doesn't state anything.
        val ivLengthCheck = this.validIvSize(104)
        val ivIsUniqueCheck = this.isUniqueIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CCM ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesGCM(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("GCM")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        val ivLengthCheck = this.validIvSize(96)
        val ivIsUniqueCheck = this.isUniqueIv()
        val ivIsRandom = this.isRandomIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-GCM ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesGcmSiv(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("GCM-SIV")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 256))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        val ivLengthCheck = this.validIvSize(96)
        val ivIsUniqueCheck = this.isUniqueIv()
        val ivIsRandomCheck = this.isRandomIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
                ivIsRandomCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-GCM-SIV ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesCBC(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CBC")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        val ivLengthCheck = this.ivSizeEqualsBlockSize()
        val ivIsRandomCheck = this.isRandomIv()

        // TODO: There are requirements concerning padding!

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                ivLengthCheck,
                ivIsRandomCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CBC ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesCTR(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CTR")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        val ivLengthCheck = this.ivSizeEqualsBlockSize()
        val ivIsUniqueCheck = this.isUniqueIv()

        // TODO: There are requirements concerning padding!

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CTR ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    // Checking asymmetric crypto

    internal fun Cipher.checkRSA(): QueryTree<Boolean> =
        this.isRSA() and this.keySizeBiggerThan(3000)

    internal fun Cipher.checkDLIES(): QueryTree<Boolean> {
        if (this !is HybridCipher) {
            return QueryTree(
                value = false,
                stringRepresentation =
                    "The algorithm is not a hybrid cipher, so it cannot be DLIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val isDLIES =
            QueryTree(
                value = this.cipherName == "DLIES",
                stringRepresentation =
                    if (cipherName == "DLIES") "The algorithm is DLIES"
                    else "The algorithm is not DLIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )

        val symmetricCipherOk = this.isSymmetricCipherOk()

        val hashFunctionOk = this.isHashFunctionOk()

        // One of the two things is redundant
        val keyexchangeOk = this.isKeyExchangeOk()
        val keysizeOk = this.keySizeBiggerThan(3000)

        return listOf(isDLIES, keysizeOk, symmetricCipherOk, hashFunctionOk, keyexchangeOk)
            .mergeWithAll()
    }

    private fun Cipher.checkECIES(): QueryTree<Boolean> {
        if (this !is HybridCipher) {
            return QueryTree(
                value = false,
                stringRepresentation =
                    "The algorithm is not a hybrid cipher, so it cannot be ECIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val isECIES =
            QueryTree(
                value = this.cipherName == "ECIES",
                stringRepresentation =
                    if (cipherName == "ECIES") "The algorithm is ECIES"
                    else "The algorithm is not ECIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )

        val symmetricCipherOk = this.isSymmetricCipherOk()

        val hashFunctionOk = this.isHashFunctionOk()

        // One of the two things is redundant
        val keyexchangeOk = this.isKeyExchangeOk()
        val keysizeOk = this.keySizeBiggerThan(250)

        return listOf(isECIES, keysizeOk, symmetricCipherOk, hashFunctionOk, keyexchangeOk)
            .mergeWithAll()
    }

    /**
     * Checks whether the protocol is TLS 1.2 with recommended ciphers and settings. [requiresPFS]
     * is set to `true` if perfect forward secrecy is required by the use-case. [forbidsPSK] should
     * be set to `true` if the use-case does not allow for a pre-shared key. Setting these
     * parameters correctly is important as they influence which ciphers are considered secure.
     */
    private fun TransportEncryption.checkTLS1_2(
        requiresPFS: Boolean = false,
        forbidsPSK: Boolean = false,
    ): QueryTree<Boolean> {
        val isTLS12 = isProtocol("TLS", 1.2f)
        if (!isTLS12.value) {
            return isTLS12
        } else if (this !is TLS1_2) {
            return QueryTree(
                value = false,
                stringRepresentation = "The protocol is not TLS 1.2",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val goodCiphersWithPFS =
            setOf(
                "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                "TLS_ECDHE_ECDSA_WITH_AES_128_CCM",
                "TLS_ECDHE_ECDSA_WITH_AES_256_CCM",
                "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
                "TLS_DHE_DSS_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_DSS_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
                "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_RSA_WITH_AES_128_CCM",
                "TLS_DHE_RSA_WITH_AES_256_CCM",
            )
        val goodCiphersWithoutPFS =
            setOf(
                "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
                "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
                "TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
                "TLS_DH_DSS_WITH_AES_128_GCM_SHA256",
                "TLS_DH_DSS_WITH_AES_256_GCM_SHA384",
                "TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
                "TLS_DH_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_DH_RSA_WITH_AES_256_GCM_SHA384",
            )
        val goodCiphersPsk =
            setOf(
                "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384",
                "TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256",
                "TLS_DHE_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_DHE_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_PSK_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_PSK_WITH_AES_128_CCM",
                "TLS_DHE_PSK_WITH_AES_256_CCM",
                "TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_RSA_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_RSA_PSK_WITH_AES_256_GCM_SHA384",
            )

        val supportedGroups =
            setOf(
                "secp256r1",
                "secp384r1",
                "secp521r1",
                "brainpoolP256r1",
                "brainpoolP384r1",
                "brainpoolP512r1",
                "ffdhe3072",
                "ffdhe4096",
            )
        val allAllowedSuites = goodCiphersWithPFS.toMutableSet()

        if (!requiresPFS) allAllowedSuites.addAll(goodCiphersWithoutPFS)
        if (!forbidsPSK) allAllowedSuites.addAll(goodCiphersPsk)

        val acceptedSuites = checkTLS12Configuration(allAllowedSuites, supportedGroups)

        // There are several other recommendations e.g. about extensions like
        // encrypt-then-mac, heartbeat, extended master secret. However, these aren't present in the
        // model yet, so we do not check them for now.

        return isTLS12 and acceptedSuites
    }

    /**
     * Checks whether the protocol is TLS 1.3 with recommended ciphers and settings. [forbidsPSK]
     * should be set to `true` if the use-case does not allow for a pre-shared key.
     */
    private fun TransportEncryption.checkTLS1_3(forbidsPSK: Boolean = false): QueryTree<Boolean> {
        val isTLS13 = isProtocol("TLS", 1.3f)
        if (this !is TLS1_3) {
            return QueryTree(
                value = false,
                stringRepresentation = "The protocol is not TLS 1.3",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        } else if (!isTLS13.value) {
            return isTLS13
        }

        val usesOnlyRecommendedPSKHandshakeModes =
            usesOnlyRecommendedPSKHandshakeModes(
                setOf(
                    "psk_ke", // Until 2026
                    "psk_dhe_ke",
                )
            )

        val usesOnlyRecommendedSupportedGroups =
            this.usesOnlyRecommendedSupportedGroups(
                setOf(
                    "secp256r1",
                    "secp384r1",
                    "secp521r1",
                    "brainpoolP256r1tls13",
                    "brainpoolP384r1tls13",
                    "brainpoolP512r1tls13",
                    "ffdhe3072",
                    "ffdhe4096",
                )
            )

        val usesOnlyRecommendedSignatureAlgorithms =
            usesOnlyRecommendedSignatureAlgorithms(
                setOf(
                    "rsa_pss_rsae_sha256",
                    "rsa_pss_rsae_sha384",
                    "rsa_pss_rsae_sha512",
                    "rsa_pss_pss_sha256",
                    "rsa_pss_pss_sha384",
                    "rsa_pss_pss_sha512",
                    "ecdsa_secp256r1_sha256",
                    "ecdsa_secp384r1_sha384",
                    "ecdsa_secp521r1_sha512",
                    "ecdsa_brainpoolP256r1tls13_sha256",
                    "ecdsa_brainpoolP384r1tls13_sha384",
                    "ecdsa_brainpoolP512r1tls13_sha512",
                )
            )

        val usesOnlyRecommendedCertSignatureAlgorithms =
            this.usesOnlyRecommendedCertSignatureAlgorithms(
                setOf(
                    "rsa_pkcs1_sha256", // Until 2025
                    "rsa_pkcs1_sha384", // Until 2025
                    "rsa_pkcs1_sha512", // Until 2025
                    "rsa_pss_rsae_sha256",
                    "rsa_pss_rsae_sha384",
                    "rsa_pss_rsae_sha512",
                    "rsa_pss_pss_sha256",
                    "rsa_pss_pss_sha384",
                    "rsa_pss_pss_sha512",
                    "ecdsa_secp256r1_sha256",
                    "ecdsa_secp384r1_sha384",
                    "ecdsa_secp521r1_sha512",
                    "ecdsa_brainpoolP256r1tls13_sha256",
                    "ecdsa_brainpoolP384r1tls13_sha384",
                    "ecdsa_brainpoolP512r1tls13_sha512",
                )
            )

        val usesOnlyRecommendedCipherSuites =
            usesOnlyRecommendedCipherSuites(
                setOf("TLS_AES_128_GCM_SHA256", "TLS_AES_256_GCM_SHA384", "TLS_AES_128_CCM_SHA256")
            )

        return isTLS13 and
            listOfNotNull(
                    usesOnlyRecommendedPSKHandshakeModes,
                    usesOnlyRecommendedSupportedGroups,
                    usesOnlyRecommendedSignatureAlgorithms,
                    usesOnlyRecommendedCipherSuites,
                    usesOnlyRecommendedCertSignatureAlgorithms,
                )
                .mergeWithAll()
    }
}
