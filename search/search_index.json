{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-does-the-cpg-library-offer","title":"What does the CPG library offer?","text":"<p>A Code Property Graph (CPG) is a graph-based representation of code which unites several concepts such as an Abstract Syntax Tree (AST), Control Flow Graph (CFG) or Evaluation Order Graph (EOG), Data Flow Graph (DFG) or Control Dependence Graph (CDG), among others, in a single supergraph. This is beneficial because the CPG contains the most relevant information to conduct static program analysis and yet, the graph provides a certain abstraction of the respective programming language.</p> <p></p> <p></p> <p></p>"},{"location":"#supported-languages","title":"Supported Languages","text":"<p>The library supports the following programming languages out of the box:</p> <ul> <li>Java (Source code, JVM bytecode and Jimple)</li> <li>C/C++</li> <li>Go</li> <li>Python</li> <li>TypeScript</li> <li>LLVM-IR</li> <li>Ruby</li> </ul> <p>Nothing suitable found? Write your own language frontend   for the respective language.   </p>"},{"location":"#built-in-analyses","title":"Built-in Analyses","text":"<p>The library currently provides different analyses:</p> <ul> <li>Dataflow Analysis</li> <li>Reachability Analysis</li> <li>Constant Propagation</li> <li>Intraprocedural Order Evaluation of Statements   </li> </ul>"},{"location":"#accessing-the-graph","title":"Accessing the Graph","text":"<p>The library can be used by analysts or tools in different ways:</p> <ul> <li>The graph can be exported to the graph database neo4j</li> <li>The CPG can be included into every project as a library</li> <li>Codyze, a tool checking for compliance of your software artifacs against certain requirements and visualizing the graph and the results in a webconsole</li> <li>We provide an API for querying the graph for interesting properties   </li> </ul>"},{"location":"#highly-extensible","title":"Highly Extensible","text":"<p>The library is easily extensible. You can add new...</p> <ul> <li>language frontends Tell me more about it!,</li> <li>passes Tell me more about it! or</li> <li>analyses.   </li> </ul>"},{"location":"#handling-incomplete-code","title":"Handling Incomplete Code","text":"<p>The code you have to analyze is missing dependencies, is under active development and might   miss some code fragments?      No problem! Our tooling provides a certain resilience against such problems.   </p>"},{"location":"#about-us","title":"About Us","text":"<p>We're a team of researchers at Fraunhofer AISEC. We're interested in different topics in the area of static program analysis. If you're interested in our work, feel free to reach out to us - we're happy to collaborate and push the boundaries of static code analysis.</p>"},{"location":"#publications","title":"Publications","text":""},{"location":"#2024","title":"2024","text":"<p>Analyzing the Impact of Copying-and-Pasting Vulnerable Solidity Code Snippets from Question-and-Answer Websites</p> <p>Konrad Weiss, Christof Ferreira Torres, Florian Wendland</p> <p>In: ACM Internet Measurement Conference (IMC). Madrid, Spain.</p> bibtex <pre><code>@inproceedings{weiss2024solidity,\n  author={Weiss, Konrad and Ferreira Torres, Christof and Wendland, Florian},\n  title={Analyzing the Impact of Copying-and-Pasting Vulnerable Solidity Code Snippets from Question-and-Answer Websites},\n  year={2024},\n  booktitle={Proceedings of the 2024 ACM on Internet Measurement Conference},\n  series={IMC '24},\n  doi = {10.1145/3646547.3688437},\n  location = {Madrid, Spain},\n  publisher={ACM}\n}</code></pre> paper"},{"location":"#2023","title":"2023","text":"<p>A Uniform Representation of Classical and Quantum Source Code for Static Code Analysis</p> <p>Maximilian Kaul, Alexander K\u00fcchler, Christian Banse</p> <p>In: IEEE International Conference on Quantum Computing and Engineering (QCE). Bellevue, WA, USA.</p> bibtex <pre><code>@inproceedings{kaul2023qcpg,\n  author={Maximilian Kaul and Alexander K\\\"uchler and Christian Banse},\n  title={A Uniform Representation of Classical and Quantum Source Code for Static Code Analysis},\n  year={2023},\n  booktitle={2023 IEEE International Conference on Quantum Computing and Engineering},\n  series={QCE '23},\n  doi={10.1109/QCE57702.2023.00115},\n  location={Bellevue, WA, USA},\n  publisher={IEEE}\n}</code></pre> preprint paper <p>AbsIntIO: Towards Showing the Absence of Integer Overflows in Binaries using Abstract Interpretation</p> <p>Alexander K\u00fcchler, Leon Wenning, Florian Wendland</p> <p>In: ACM ASIA Conference on Computer and Communications Security (Asia CCS). Melbourne, VIC, Australia.</p> bibtex <pre><code>@inproceedings{kuechler2023absintio,\n  author={Alexander K\\\"uchler and Leon Wenning and Florian Wendland},\n  title={AbsIntIO: Towards Showing the Absence of Integer Overflows in Binaries using Abstract Interpretation},\n  year={2023},\n  booktitle={ACM ASIA Conference on Computer and Communications Security},\n  series={Asia CCS '23},\n  doi={10.1145/3579856.3582814},\n  location={Melbourne, VIC, Australia},\n  publisher={ACM}\n}</code></pre> paper"},{"location":"#2022","title":"2022","text":"<p>Representing LLVM-IR in a Code Property Graph</p> <p>Alexander K\u00fcchler, Christian Banse</p> <p>In: 25th Information Security Conference (ISC). Bali, Indonesia.</p> bibtex <pre><code>@inproceedings{kuechler2022representing,\n  author={Alexander K\\\"uchler and Christian Banse},\n  title={Representing LLVM-IR in a Code Property Graph},\n  year={2022},\n  booktitle={25th Information Security Conference},\n  series={ISC},\n  doi={10.1007/978-3-031-22390-7\\_21},\n  location={Bali, Indonesia},\n  publisher={Springer}\n}</code></pre> preprint paper <p>A Language-Independent Analysis Platform for Source Code</p> <p>Konrad Weiss, Christian Banse</p> bibtex <pre><code>@misc{weiss2022a,\n  doi = {10.48550/ARXIV.2203.08424},\n  url = {https://arxiv.org/abs/2203.08424},\n  author = {Weiss, Konrad and Banse, Christian},\n  title = {A Language-Independent Analysis Platform for Source Code},\n  publisher = {arXiv},\n  year = {2022},\n}</code></pre> paper"},{"location":"#2021","title":"2021","text":"<p>Cloud Property Graph: Connecting Cloud Security Assessments with Static Code Analysis</p> <p>Christian Banse, Immanuel Kunz, Angelika Schneider, Konrad Weiss</p> <p>In: 2021 IEEE 14th International Conference on Cloud Computing (CLOUD). Los Alamitos, CA, USA</p> bibtex <pre><code>@inproceedings{banse2021cloudpg,\n  author = {Christian Banse and Immanuel Kunz and Angelika Schneider and Konrad Weiss},\n  booktitle = {2021 IEEE 14th International Conference on Cloud Computing (CLOUD)},\n  title = {Cloud Property Graph: Connecting Cloud Security Assessments with Static Code Analysis},\n  year = {2021},\n  pages = {13-19},\n  doi = {10.1109/CLOUD53861.2021.00014},\n  url = {https://doi.ieeecomputersociety.org/10.1109/CLOUD53861.2021.00014},\n  publisher = {IEEE Computer Society},\n  address = {Los Alamitos, CA, USA},\n  month = {sep}\n}</code></pre> preprint paper"},{"location":"API/","title":"API Reference","text":"<p>We auto-generate an API reference using dokka. The following versions are available:</p> <ul> <li>main</li> <li>v7.0.1</li> </ul>"},{"location":"CPG/impl/","title":"Implementation and Concepts","text":"<p>The translation of source code to the graph consists of two main steps. First, the source code is parsed and transferred to the CPG nodes by a so-called Language Frontend. Then, Passes refine the information which is kept in the graph. These two stages are strictly separated one from each other.</p> <p> </p> <ul> <li>Languages and Language Frontends</li> <li>Scopes</li> <li>Passes</li> <li>Symbol Resolution</li> </ul>"},{"location":"CPG/impl/design_principles/","title":"Design Principles","text":""},{"location":"CPG/impl/design_principles/#the-cpg-represents-the-codes","title":"The CPG represents the code's ...","text":"<ul> <li>Structure/Syntax</li> <li>Data Flows</li> <li>Execution Order/Control Flow</li> <li>Variable Usage</li> <li>Calls</li> <li>The Type System</li> </ul>"},{"location":"CPG/impl/design_principles/#the-cpg-should-parse","title":"The CPG should parse ...","text":"<ul> <li>Incomplete code</li> <li>Code with missing toolchains</li> <li>With resilience to incorrect code</li> <li>Language heterogeneous projects</li> </ul>"},{"location":"CPG/impl/design_principles/#cpg-library-users-should-be-able-to","title":"CPG-Library users should be able to ...","text":"<ul> <li>Load projects and single files</li> <li>Visualize and analyze code</li> <li>Implement and register new Language Frontends</li> <li>Extends and modify existing components, e.g., passes</li> <li>Parse code incrementally</li> </ul>"},{"location":"CPG/impl/design_principles/#the-cpg-transformation-should-be","title":"The CPG-Transformation should be ...","text":"<ul> <li>Language independent: Allow for language independent and cross-language queries</li> <li>Information-rich: contain language-specific information in generalized structures</li> <li>Fast (enough).<ul> <li>Small Projects/Development projects should be analyzable in real-time, at most some seconds.</li> <li>Large libraries should take no longer than a few hours.</li> <li>About 5 to 10 times as long as the compilation process.</li> </ul> </li> </ul>"},{"location":"CPG/impl/language/","title":"Implementation and Concepts: Language and Language Frontends","text":"<p>Even though we are aiming for a language-independent representation of source code, we still need to parse source code depending on the original programming language used. Therefore, we are introduce two concepts that help developers and users to understand how the CPG translates language-specific code into an abstract form. </p>"},{"location":"CPG/impl/language/#language","title":"<code>Language</code>","text":"<p>The first concept is a <code>Language</code>. It represents the programming language as a general concept and contains meta-information about it. This includes:</p> <ul> <li>The name of the language, e.g. C++</li> <li>The delimiter used to separate namespaces, e.g., <code>::</code></li> <li>The <code>LanguageFrontend</code> used to parse it</li> <li>Additional <code>LanguageTrait</code> implementations</li> </ul> <p>Each <code>Node</code> has a <code>language</code> property that specifies its language.</p>"},{"location":"CPG/impl/language/#languagetrait","title":"<code>LanguageTrait</code>","text":"<p>A language trait aims to further categorize a programming language based on conceptual paradigms. This can be easily extended by introducing new interfaces based on <code>LanguageTrait</code>. Examples include:</p> <ul> <li>Are default arguments supported?</li> <li>Does the language have structs or classes?</li> <li>Are function pointers supported?</li> <li>Are templates or generics used in the language?</li> <li>Do we need some special knowledge to resolve symbols, calls, variables?</li> </ul> <p>These traits are used during the pass execution phase to fine-tune things like call resolution or type hierarchies.</p>"},{"location":"CPG/impl/language/#languagefrontend","title":"<code>LanguageFrontend</code>","text":"<p>In contrast to the <code>Language</code> concept, which represents the generic concept of a programming language, a <code>LanguageFrontend</code> is a specific module in the CPG library that does the actual translating of a programming language's source code into our CPG representation.</p> <p>At minimum a language frontend needs to parse the languages' code and translate it to specific CPG nodes. It will probably use some library to retrieve the abstract syntax tree (AST). The frontend will set the nodes' <code>AST</code> edges and establish proper scopes via the scope manager. Everything else, such as call or symbol resolving is optional and will be done by later passes. However, if a language frontend is confident in setting edges, such as <code>REFERS_TO</code>, it is allowed to and this is respected by later passes. However, one must be extremely careful in doing so.</p> <p>The frontend has a limited life-cycle and only exists during the translation phase. Later, during the execution of passes, the language frontend will not exist anymore. Language-specific customization of passes are done using <code>LanguageTraits</code>.</p> <p>To create nodes, a language frontend MUST use the node builder functions in the <code>ExpressionBuilder</code>, <code>DeclarationBuilder</code> or <code>StatementBuilder</code>. These are Kotlin extension functions that automatically inject the context, such as language, scope or code location of a language frontend or its handler into the created nodes.</p>"},{"location":"CPG/impl/language/#supporting-a-new-language","title":"Supporting a new language","text":"<p>To support a new language, all you have to do is to</p> <ul> <li>Provide a new <code>Language</code>. Here, you have to think about the features of the   programming language and which <code>LanguageTraits</code> the respective language has to   implement. With this, you provide the respective fine-tuning to make the   Passes work properly.</li> <li>Implement a new <code>LanguageFrontend</code> which is executed if a file matches the new   <code>Language</code>. The requirements of the frontends are described above.</li> </ul> <p>To make use of the respective frontend by the CPG, you have to configure the translation accordingly. This is done by the <code>TranslationConfiguration</code> where you register your new language by calling one of the <code>registerLanguage()</code> methods. As an example <pre><code>val config: TranslationConfiguration = TranslationConfiguration\n    .builder()\n    // More configuration\n    .registerLanguage(MyNewLanguage()) // Option 1\n    .registerLanguage&lt;MyOtherNewLanguage&gt;() // Option 2\n    .registerLanguage(\"MyThirdNewLanguage\") // Option 3\n    .build()\n</code></pre></p>"},{"location":"CPG/impl/passes/","title":"Implementation and Concepts: Passes","text":""},{"location":"CPG/impl/passes/#what-is-a-pass","title":"What is a Pass?","text":"<p>Passes get a prebuilt CPG that at least contains the CPG-AST and output a modified graph. Their purpose is to extend the syntactic representation of code with additional nodes and edges to represent the semantics of the program. Passes can be executed in sequence, where the output of the previous pass serves as input of the next pass.</p>"},{"location":"CPG/impl/passes/#creating-a-new-pass","title":"Creating a new Pass","text":"<p>The user of the cpg library can implement her own passes. Each pass needs to extend the class <code>Pass</code> and implement its base function<code>accept(result: TranslationResult)</code>. The remaining structure of the pass is free to be designed by the implementer.</p>"},{"location":"CPG/impl/passes/#registering-a-pass","title":"Registering a Pass","text":"<p>A newly created pass has to be registered with the <code>TranslationManager</code> through its builder by calling <pre><code>val configuration = TranslationConfiguration.builder().\n    // ...\n    .registerPass(...)\n</code></pre></p>"},{"location":"CPG/impl/passes/#modifying-a-pass","title":"Modifying a Pass","text":"<p>A preexisting pass can be modified by extending it and overwriting its functions. For this purpose, all member functions of existing library passes have the visibility <code>protected</code>. Depending on the modified pass, internal constructs have to be respected.</p> <p>For example, the <code>EvaluationOrderGraphPass</code> uses an internal handle structure. When extending this pass, it is necessary to add handlers of new Node types to the internal handler map. If a developer needs to override an existing handler, the handle has to be implemented with the same signature to use the polymorphism feature. Additionally, the mapping of <code>node type -&gt; handler</code> needs to be replaced by a new entry <code>node type -&gt; overridden</code> handler.</p>"},{"location":"CPG/impl/passes/#ordering-passes","title":"Ordering Passes","text":"<p>Passes may depend on the information added by another pass. This requires us to enforce the order in which passes are executed. To do so, we provide the following annotations for the passes:</p> <ul> <li><code>DependsOn(other: KClass&lt;out Pass&gt;, softDependency: Boolean = false)</code> -- The annotated pass is executed after    the other pass(es). If <code>softDependency</code> is set to <code>false</code>, it automatically    registers these passes if they haven't been registered by the user.</li> <li><code>ExecuteBefore(other: KClass&lt;out Pass&gt;, ...)</code> -- The annotated pass is executed    before the other pass(es) specified.</li> <li><code>ExecuteFirst</code> -- The annotated pass is executed as the first pass if possible.</li> <li><code>ExecuteLast</code> -- The annotated pass is executed as the last pass if possible.</li> <li><code>RequiredFrontend(frontend: KClass&lt;out LanguageFrontend&gt;)</code> -- The annotated pass    is only executed if the frontend has been used.</li> <li><code>RequiresLanguageTrait(trait: KClass&lt;out LanguageTrait&gt;)</code> -- The annotated pass   is only executed if the <code>language</code> of the <code>TranslationUnit</code> which is currently studied   implements the given <code>trait</code>.</li> </ul>"},{"location":"CPG/impl/scopes/","title":"Scopes and Symbols","text":"<p>The concept of scopes and symbols are at the heart of every programming language and thus are also the core of static analysis. Both concepts consist in the CPG library through the types <code>Scope</code> and <code>Symbol</code> respectively.</p> <p>A \"symbol\" can be seen as an identifier in most programming languages, referring to variables or functions. Symbols are often grouped in scopes, which defines the visibility of a symbol, e.g. a slice of a program that can \"see\" the symbol. Often this is also synonymous with the life-time of a variable, e.g., that its memory will be freed (or collected by a garbage collector) once it goes \"out of scope\".</p> <pre><code>// This defines a symbol \"a\" in the global/file scope.\n// Its visibility is global within the file.\nint a = 1;\n\nint main() {\n    // this defines another symbol \"a\" in a function/block scope. \n    // Its visibility is limited to the block it is defined in. \n    int a = 1;\n}\n</code></pre> <p>Usually symbols declared in a local scope override the declaration of a symbol in a higher (e.g., global scope), which is also referred to as \"shadowing\". This needs to be taken into account when resolving symbols to their declarations.</p> <p>The <code>Scope</code> class holds all its symbols in the <code>Scope::symbols</code> property. More specifically, this property is a <code>SymbolMap</code>, which is a type alias to a map, whose key type is a <code>Symbol</code> and whose value type is a list of <code>Declaration</code> nodes. This is basically a symbol lookup table for all symbols in its scope. It is a map of a list because some programming languages have concepts like function overloading, which leads to the declaration of multiple <code>FunctionDeclaration</code> nodes under the same symbol in one scope. In the current implementation, a <code>Symbol</code> is just a typealias for a string, and it is always \"local\" to the scope, meaning that it MUST NOT contain any qualifier. If you want to refer to a fully qualified identifier, a <code>Name</code> must be used. In the future, we might consider merging the concepts of <code>Symbol</code> and <code>Name</code>. </p> <p>For a frontend or pass developer, the main interaction point with scopes and symbols is through the <code>ScopeManager</code>. The scope manager is available to all nodes via the <code>TranslationContext</code> and also injected in frontend, handlers and passes.</p>"},{"location":"CPG/impl/scopes/#hierarchy-of-scopes","title":"Hierarchy of Scopes","text":"<p>Each scope (except the <code>GlobalScope</code>) can have a parent and possible child scopes. This can be used to model a hierarchy of scopes within a program. For example using the snippet above, the following scopes are defined in the CPG:</p> <ul> <li>A <code>GlobalScope</code> that comprises the whole file</li> <li>A <code>FunctionScope</code> that comprises the function <code>main</code></li> <li>A <code>BlockScope</code> that comprises the function body</li> </ul> <p>Note, that each programming language is different when it comes to scoping and this needs to be thought of by a frontend developer. For example in C/C++ each block introduced by <code>{}</code> introduces a new scope and variables can be declared only for such a block, meaning that each <code>for</code>, <code>if</code> and other statements also introduce a new scope. In contrast, Python only differentiates between a global scope, function and class scope. </p>"},{"location":"CPG/impl/scopes/#defining-scopes-and-declaring-symbols","title":"Defining Scopes and Declaring Symbols","text":"<p>In order to define new scopes, the <code>ScopeManager</code> offers two main APIs:</p> <ul> <li><code>enterScope(node)</code>, which specifies that <code>node</code> will declare a new scope and that an appropriate <code>Scope</code> (or derived type) will be created </li> <li><code>leaveScope(node)</code>, which closes the scope again</li> </ul> <p>It is important that every opened scope must also be closed again. When scopes are nested, they also need to be closed in reverse order.</p> <pre><code>// We are inside the global scope here and want to create a new function\nvar func = newFunctionDeclaration(\"main\")\n\n// Create a function scope\nscopeManager.enterScope(func)\n\n// Create a block scope for the body because our language works this way\nvar body = newBlock()\nfunc.body = body\nscopeManager.enterScope(body)\n\n// Add statements here\nbody.statements += /* ... */\n\n// Leave block scope    \nscopeManager.leaveScope(body)\n\n// Back to global scope, add the function to global scope\nscopeManager.leaveScope(func)\nscopeManager.addDeclaration(func)\n</code></pre> <p>Inside the scope, declarations can be added with <code>ScopeManager::addDeclaration</code>. This takes care of adding the declaration to an appropriate place in the AST (which beyond the scope of this document) and also adds the <code>Declaration</code> to the <code>Scope</code> under the appropriate <code>Symbol</code>.</p>"},{"location":"CPG/impl/scopes/#looking-up-symbols","title":"Looking up Symbols","text":"<p>During different analysis steps, e.g., in different passes, we want to find certain symbols or lookup the declaration(s) belonging to a particular symbol. There are two functions in order to do so - a \"higher\" level concept in the <code>ScopeManager</code> and a \"lower\" level function on the <code>Scope</code> itself.</p> <p>The lower level one is called <code>Scope::lookupSymbol</code> and can be used to retrieve a list of <code>Declaration</code> nodes that belong to a particular <code>Symbol</code> that is \"visible\" the scope. It does so by first looking through its own <code>Scope::symbols</code>. If no match was found, the scope is traversed upwards to its <code>Scope::parent</code>, until a match is found. Furthermore, additional logic is needed to resolve symbol that are pointing to another scope, e.g., because they represent an <code>ImportDeclaration</code>. </p> <pre><code>var scope = /* ... */\nvar declarations = scope.lookupSymbol(\"a\") {\n    // Some additional predicate if we want\n}\n</code></pre> <p>Additionally, the lookup can be fine-tuned by an additional predicate. However, this should be used carefully as it restricts the possible list of symbols very early. In most cases the list of symbols should be quite exhaustive at first to find all possible candidates and then selecting the best candidate in a second step (e.g., based on argument types for a function call).</p> <p>While the aforementioned API works great if we already have a specific start scope and local <code>Symbol</code>, we often start our resolution process with a <code>Name</code> -- which could potentially be qualified, such as <code>std::string</code>. Therefore, the \"higher level\" function <code>ScopeManager::lookupSymbolByName</code> can be used to retrieve a list of candidate declarations by a given <code>Name</code>. In a first step, the name is checked for a potential scope qualifier (<code>std</code> in this example). If present, it is extracted and the search scope is set to it. This is what is usually referred to as a \"qualified lookup\". Otherwise, the local part of the name is used to start the lookup, in what is called an \"unqualified lookup\". In both cases, the actual lookup is delegated to <code>ScopeManager::lookupSymbols</code>, but with different parameters.</p> <pre><code>var name = parseName(\"std::string\")\n// This will return all the 'string' symbols within the 'std' name scope\nvar stringSymbols = scopeManager.lookupSymbolByName(name)\n</code></pre> <p>Developers should avoid symbol lookup during frontend parsing, since often during parsing, only a limited view of all symbols is available. Instead, a dedicated pass that is run on the complete translation result is the preferred option. Apart from that, the main usage of this API is in the SymbolResolver.</p>"},{"location":"CPG/impl/symbol-resolver/","title":"Symbol Resolution","text":"<p>This pages describes the main functionality behind symbol resolution in the CPG library. This is mostly done by the <code>SymbolResolver</code> pass, in combination with the symbol lookup API (see Scopes and Symbols). In addition to the lookup of a symbol, the resolution takes the input of the lookup and provides a \"definite\" decision which symbol is used. This mostly referred to symbols / names used in a <code>Reference</code> or a <code>CallExpression</code> (which also has a reference as its <code>CallExpression::callee</code>).</p>"},{"location":"CPG/impl/symbol-resolver/#the-symbolresolver-pass","title":"The <code>SymbolResolver</code> Pass","text":"<p>The <code>SymbolResolver</code> pass takes care of the heavy lifting of symbol (or rather reference) resolving:</p> <ul> <li>It sets the <code>Reference::refersTo</code> property,</li> <li>and sets the <code>CallExpression::invokes</code> property,</li> <li>and finally takes cares of operator overloading (if the language supports it).</li> </ul> <p>In a way, it can be compared to a linker step in a compiler. The pass operates on a single <code>Component</code> and starts by identifying EOG starter nodes within the component. These node \"start\" an EOG sub-graph, i.e., they do not have any previous EOG edges. The symbol resolver uses the <code>ScopedWalker</code> with a special set-up that traverses the EOG starting with each EOG starter node until it reaches the end. This ensures that symbols are resolved in the correct order of \"evaluation\", e.g., that a base of a member expression is resolved before the expression itself. This ensures that necessary type information on the base are available in order to resolve appropriate fields of the member expression.</p> <p>The symbol resolver itself has gone through many re-writes over the years and there is still some code left that we consider legacy. These functions are marked as such, and we aim to remove them slowly.</p>"},{"location":"CPG/impl/symbol-resolver/#resolving-references","title":"Resolving References","text":"<p>The main functionality lies in <code>ScopeManager::handleReference</code>. For all <code>Reference</code> nodes (that are not <code>MemberExpression</code> nodes) we use the symbol lookup API to find declaration candidates for the name the reference is referring to. This candidate list is then stored in <code>Reference::candidates</code>. If the reference is the <code>CallExpression::callee</code> property of a call, we abort here and jump to Resolve Calls.</p> <p>Otherwise, we currently take the first entry of the candidate list and set the <code>Reference::refersTo</code> property to it.</p>"},{"location":"CPG/impl/symbol-resolver/#resolve-calls","title":"Resolve Calls","text":"<p>Prequisite: The <code>CallExpression::callee</code> reference must have been resolved (see Resolving References).</p>"},{"location":"CPG/impl/types/","title":"Types","text":"<p>We currently maintain a rather complex type system in the CPG, with several layers of inheritance. The most basic abstract type is <code>Type</code>, which holds properties common to all types.</p>"},{"location":"CPG/impl/types/#hastype","title":"<code>HasType</code>","text":"<p>Not all nodes in the CPG have a type. For example, a <code>NamespaceDeclaration</code> does not have a type, but a <code>FunctionDeclaration</code> has a corresponding <code>FunctionType</code>. To make this distinction, we have the <code>HasType</code> interface, which is implemented by all nodes that have a type. The <code>HasType</code> interface requires mainly the implementation of two properties:</p>"},{"location":"CPG/impl/types/#type","title":"<code>type</code>","text":"<p>This refers to the type of the node at compile-time and is a single <code>Type</code> object. For example, when declaring a variable <code>int i</code> in C/C++, the <code>type</code> of the variable <code>i</code> is <code>int</code>. </p> <p>Often, languages allow to skip setting the explicitly, for example using <code>var i = 1</code> in Java. In this case, the type is inferred by the compiler and set to <code>int</code>. This still happens at compile-time, since the compiler is able to deduce the type, and it will stay the same during runtime. To simulate this, the initial <code>type</code> will be set to <code>AutoType</code>. Once we know the correct type, the CPG will also infer the type of the variable <code>i</code> to <code>int</code> through its type-observer system and replace the <code>AutoType</code> with the correct type.</p>"},{"location":"CPG/impl/types/#assignedtypes","title":"<code>assignedTypes</code>","text":"<p>The second property is <code>assignedTypes</code>, which is a set of <code>Type</code> objects. This property is used to store the types that are assigned to the node at runtime. For example considering the following C++ code:</p> <pre><code>Interface obj;\nif (something) {\n    obj = new A();\n} else {\n    obj = new B();\n}\n</code></pre> <p>The <code>assignedTypes</code> of <code>obj</code> will be a set containing <code>A</code> and <code>B</code> (plus the interface <code>Interface</code> itself), since the type of <code>obj</code> can be either <code>A</code> or <code>B</code> at runtime. This feature is especially important for languages that allow dynamic typing, such as JavaScript or Python, where the type of a variable can change at runtime (see below).</p>"},{"location":"CPG/impl/types/#dynamically-typed-languages","title":"Dynamically Typed Languages","text":"<p>Dynamically typed languages such as Python or JavaScript present an extra challenge because for most (if not all) variables, the type is not known at compile-time. In these languages, the type of a variable can change at runtime, and the CPG needs to be able to represent this. We therefore introduce a special <code>DynamicType</code> type class and assign it to <code>type</code> of most nodes. There are some exceptions to this rule: - <code>ConstructExpression</code>: When we construct an object, we know the type of the object at compile-time, so we set the <code>type</code> to the type of the object. - <code>Literal</code>: When we have a literal, we also know the type at compile-time, so we set the <code>type</code> to the type of the literal, for example <code>str</code> for string-based literals in Python. - Lists, dictionaries, comprehensions: When we encounter a collection comprehension, list or dictionary expressions, we also know a partial type at compile-time, so we set the <code>type</code> to the type of the collection, e.g. a list or a dictionary in Python.</p>"},{"location":"CPG/specs/","title":"Specifications","text":"<p>The core of the code property graph are its nodes and edges. Here, you find the links to the specifications of the following concepts:</p> <ul> <li>Explore our Graph Model</li> <li>Data Flow Graph (DFG)</li> <li>Data Flow Graph (DFG) Function Summaries</li> <li>Evaluation Order Graph (EOG)</li> <li>Program Dependence Graph (DFG)</li> <li>Our inference rules which may modify the graph</li> <li>Read about our overlay graph if you want to encode more information</li> </ul>"},{"location":"CPG/specs/dfg-function-summaries/","title":"Specification: Data Flow Graph - Function Summaries","text":"<p>For functions and methods which are part of the analyzed codebase, the CPG can track data flows inter-procedurally to some extent. However, for all functions and methods which cannot be analyzed, we have no information available. For this case, we provide the user a way to specify custom summaries of the data flows through the function. To do so, you need to fill a JSON or YAML file as follows:</p> <ul> <li>The outer element is a list/array</li> <li>In this list, you add elements, each of which summarizes the flows for one function/method</li> <li>The element consists of two objects: The <code>functionDeclaration</code> and the <code>dataFlows</code></li> <li>The <code>functionDeclaration</code> consists of:</li> <li><code>language</code>: The FQN of the <code>Language</code> element which this function is relevant for.</li> <li><code>methodName</code>: The FQN of the function or method. We use this one to identify the relevant function/method. Do not forget to add the class name and use the separators as specified by the <code>Language</code>.</li> <li><code>signature</code> (optional): This optional element allows us to differentiate between overloaded functions (i.e., two functions have the same FQN but accept different arguments). If no <code>signature</code> is specified, it matches to any function/method with the name you specified. The <code>signature</code> is a list of FQNs of the types (as strings)</li> <li>The <code>dataFlows</code> element is a list of objects with the following elements:</li> <li><code>from</code>: A description of the start-node of a DFG-edge. Valid options:<ul> <li><code>paramX</code>: where <code>X</code> is the offset (we start counting with 0)</li> <li><code>base</code>: the receiver of the method (i.e., the object the method is called on)</li> </ul> </li> <li><code>to</code>: A description of the end-node of the DFG-edge. Valid options:<ul> <li><code>paramX</code> where <code>X</code> is the offset (we start counting with 0)</li> <li><code>base</code> the receiver of the method (i.e., the object the method is called on)</li> <li><code>return</code> the return value of the function</li> <li><code>returnX</code> where <code>X</code> is a number and specifies the index of the return value (if multiple values are returned).</li> </ul> </li> <li><code>dfgType</code>: Here, you can give more information. Currently, this is unused but should later allow us to add the properties to the edge.</li> </ul> <p>An example of a file could look as follows:</p> JSONYAML <pre><code>[\n  {\n    \"functionDeclaration\": {\n      \"language\": \"de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage\",\n      \"methodName\": \"java.util.List.addAll\",\n      \"signature\": [\"int\", \"java.util.Object\"]\n    },\n    \"dataFlows\": [\n      {\n        \"from\": \"param1\",\n        \"to\": \"base\",\n        \"dfgType\": \"full\"\n      }\n    ]\n  },\n  {\n    \"functionDeclaration\": {\n      \"language\": \"de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage\",\n      \"methodName\": \"java.util.List.addAll\",\n      \"signature\": [\"java.util.Object\"]\n    },\n    \"dataFlows\": [\n      {\n        \"from\": \"param0\",\n        \"to\": \"base\",\n        \"dfgType\": \"full\"\n      }\n    ]\n  },\n  {\n    \"functionDeclaration\": {\n      \"language\": \"de.fraunhofer.aisec.cpg.frontends.cxx.CLanguage\",\n      \"methodName\": \"memcpy\"\n    },\n    \"dataFlows\": [\n      {\n        \"from\": \"param1\",\n        \"to\": \"param0\",\n        \"dfgType\": \"full\"\n      }\n    ]\n  }\n]\n</code></pre> <pre><code>- functionDeclaration:\n    language: de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage\n    methodName: java.util.List.addAll\n    signature:\n      - int\n      - java.util.Object\n    dataFlows:\n      - from: param1\n        to: base\n        dfgType: full\n\n- functionDeclaration:\n    language: de.fraunhofer.aisec.cpg.frontends.java.JavaLanguage\n    methodName: java.util.List.addAll\n    signature:\n      - java.util.Object\n    dataFlows:\n      - from: param0\n        to: base\n        dfgType: full\n\n- functionDeclaration:\n    language: de.fraunhofer.aisec.cpg.frontends.cxx.CLanguage\n    methodName: memcpy\n    dataFlows:\n      - from: param1\n        to: param0\n        dfgType: full\n</code></pre> <p>This file configures the following edges:</p> <ul> <li>For a method declaration in Java <code>java.util.List.addAll(int, java.util.Object)</code>, the parameter 1 flows to the base (i.e., the list object)</li> <li>For a method declaration in Java <code>java.util.List.addAll(java.util.Object)</code>, the parameter 0 flows to the base (i.e., the list object)</li> <li>For a function declaration in C <code>memcpy</code> (and thus also CXX <code>std::memcpy</code>), the parameter 1 flows to parameter 0.</li> </ul> <p>Note: If multiple function summaries match a method/function declaration (after the normal matching considering the language, local name of the function/method, signature if applicable and type hierarchy of the base object), we use the following routine to identify ideally a single entry:</p> <ol> <li>We filter for existing signatures since it's more precisely specified than the generic \"catch all\" without a signature-element.</li> <li>We filter for the most precise class of the base.</li> <li>If there are still multiple options, we take the longest signature.</li> <li>If this also didn't help to get a precise result, we iterate through the parameters and for index <code>i</code>, we pick the entry with the most precise matching type. We start with index 0 and count upwards, so if param0 leads to a single result, we're done and other entries won't be considered even if all the remaining parameters are more precise or whatever.</li> <li>If nothing helped to get a unique entry, we pick the first remaining entry and hope it's the most precise one.</li> </ol>"},{"location":"CPG/specs/dfg/","title":"Specification: Data Flow Graph","text":"<p>The Data Flow Graph (DFG) is built as edges between nodes. Each node has a set of incoming data flows (<code>prevDFG</code>) and outgoing data flows (<code>nextDFG</code>). In the following, we summarize how different types of nodes construct the respective data flows.</p>"},{"location":"CPG/specs/dfg/#callexpression","title":"CallExpression","text":"<p>Interesting fields:</p> <ul> <li><code>invokes: List&lt;FunctionDeclaration&gt;</code>: A list of the functions which are called</li> <li><code>arguments: List&lt;Expression&gt;</code>: The arguments which are used in the function   call</li> </ul> <p>A call expressions calls another function. We differentiate two types of call expressions: 1) the called function is implemented in the program (and we can analyze the code) and 2) the called function cannot be analyzed (e.g., this is the case for library/API functions). For the first case, the <code>invokes</code> list contains values, in the second case, the list is empty.</p>"},{"location":"CPG/specs/dfg/#case-1-known-function","title":"Case 1: Known function","text":"<p>For each function in the <code>invokes</code> list, the arguments of the call expression flow to the function's parameters. The value of the function declaration flows to the call.</p> <p>Scheme:   <pre><code>flowchart LR\n  node([CallExpression]) -.- invokes[\"invokes[j]\"];\n  node -.- arguments[\"arguments[i]\"];\n  invokes ==&gt; decl([FunctionDeclaration])\n  decl -.- parameters[\"parameters[i]\"]\n  arguments -- \"for all i: DFG\" --&gt; parameters\n  invokes -- \"forall j: DFG\" --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#case-2-unknown-function","title":"Case 2: Unknown function","text":"<p>The base and all arguments flow to the call expression.</p> <p>Scheme:   <pre><code>flowchart LR\n  arguments[\"arguments[i]\"] -- \"for all i: DFG\" --&gt; node([CallExpression]);\n  base -- DFG --&gt; node;\n  arguments -.- node;\n  node -.- base;</code></pre></p>"},{"location":"CPG/specs/dfg/#castexpression","title":"CastExpression","text":"<p>Interesting fields:</p> <ul> <li><code>expression: Expression</code>: The inner expression which has to be cast</li> </ul> <p>The value of the <code>expression</code> flows to the cast expression. Scheme: <pre><code>  flowchart LR\n    node([CastExpression]) -.- expression;\n    expression -- DFG --&gt; node;</code></pre></p>"},{"location":"CPG/specs/dfg/#assignexpression","title":"AssignExpression","text":"<p>Interesting fields:</p> <ul> <li><code>lhs: List&lt;Expression&gt;</code>: All expressions on the left-hand side of the   assignment.</li> <li><code>rhs: List&lt;Expression&gt;</code>: All expressions on the right-hand side of the   assignment.</li> </ul>"},{"location":"CPG/specs/dfg/#case-1-normal-assignment-operatorcode","title":"Case 1: Normal assignment (<code>operatorCode: =</code>)","text":"<p>The <code>rhs</code> flows to <code>lhs</code>. In some languages, it is possible to have an assignment in a subexpression (e.g. <code>a + (b=1)</code>). For this reason, if the assignment's ast parent is not a <code>Block</code> (i.e., a block of statements), we also add a DFG edge to the whole operator. If the <code>lhs</code> consists of multiple variables (or a tuple), we try to split up the <code>rhs</code> by the index. If we can't do this, the whole <code>rhs</code> flows to all variables in <code>lhs</code>.</p> <p>Scheme:</p> <ul> <li>Standard case:   <pre><code>flowchart LR\n    node([AssignExpression]) -.- rhs(rhs);\n      rhs -- DFG --&gt; lhs;\n    node([AssignExpression]) -.- lhs(lhs);</code></pre></li> <li>If the assignment happens inside another statement/expression (not inside a   <code>Block</code>):   <pre><code>flowchart LR\n    node([AssignExpression]) -.- lhs(lhs);\n    node([AssignExpression]) -.- rhs(rhs);\n    rhs -- DFG --&gt; lhs;\n    rhs -- DFG --&gt; node;</code></pre></li> <li>Since <code>lhs</code> and <code>rhs</code> can consist of multiple values, if size of <code>lhs</code> and   <code>rhs</code> is equal, we actually make the DFG-edges for each indexed value:    <pre><code>flowchart LR\n    node([AssignExpression]) -.- rhs(\"rhs[i]\");\n      rhs -- \"for all i: DFG[i]\" --&gt; lhs;\n    node([AssignExpression]) -.- lhs(\"lhs[i]\");</code></pre></li> </ul>"},{"location":"CPG/specs/dfg/#case-2-compound-assignment-operatorcode-","title":"Case 2: Compound assignment (<code>operatorCode: *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, |=</code> )","text":"<p>The <code>lhs</code> and the <code>rhs</code> flow to the binary operator expression, the binary operator flows to the <code>lhs</code>.</p> <p>Scheme: <pre><code>  flowchart LR\n    node([BinaryOperator]) -.- lhs(lhs);\n    node([BinaryOperator]) -.- rhs(rhs);\n    lhs -- DFG --&gt; node;\n    rhs -- DFG --&gt; node;\n    node == DFG ==&gt; lhs;</code></pre></p> <p>Dangerous: We have to ensure that the first two operations are performed before the last one</p>"},{"location":"CPG/specs/dfg/#binaryoperator","title":"BinaryOperator","text":"<p>Interesting fields:</p> <ul> <li><code>operatorCode: String</code>: String representation of the operator</li> <li><code>lhs: Expression</code>: The left-hand side of the operation</li> <li><code>rhs: Expression</code>: The right-hand side of the operation</li> </ul> <p>We have to differentiate between the operators. We can group them into three categories: 1) Assignment, 2) Assignment with a Computation and 3) Computation.</p> <p>The <code>lhs</code> and the <code>rhs</code> flow to the binary operator expression.</p> <p>Scheme:   <pre><code>flowchart\n  node([BinaryOperator]) -.- lhs(lhs);\n  node([BinaryOperator]) -.- rhs(rhs);\n  rhs -- DFG --&gt; node;\n  lhs -- DFG --&gt; node;</code></pre></p>"},{"location":"CPG/specs/dfg/#newarrayexpression","title":"NewArrayExpression","text":"<p>Interesting fields:</p> <ul> <li><code>initializer: Expression</code>: The initialization values of the array.</li> </ul> <p>The <code>initializer</code> flows to the array creation expression.</p> <p>Scheme:   <pre><code>flowchart LR\n  node([NewArrayExpression]) -.- initializer(initializer)\n  initializer -- DFG --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#newexpression","title":"NewExpression","text":"<p>Interesting fields:</p> <ul> <li><code>initializer: Expression</code>: The initializer of the expression.</li> </ul> <p>The <code>initializer</code> flows to the whole expression.</p> <p>Scheme: <pre><code>  flowchart LR\n    node([NewExpression]) -.- initializer(initializer)\n    initializer -- DFG --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#subscriptexpression","title":"SubscriptExpression","text":"<p>Interesting fields:</p> <ul> <li><code>arrayExpression: Expression</code>: The array which is accessed</li> <li><code>subscriptExpression: Expression</code>: The index which is accessed</li> </ul> <p>The <code>arrayExpression</code> flows to the subscription expression. This means, we do not differentiate between the field which is accessed.</p> <p>Scheme:   <pre><code>flowchart LR\n  arrayExpression -- DFG --&gt; node([SubscriptExpression]);\n  arrayExpression -.- node;</code></pre></p>"},{"location":"CPG/specs/dfg/#collectioncomprehension","title":"CollectionComprehension","text":"<p>Interesting fields:</p> <ul> <li>`comprehensionExpressions:</li> <li>List`: The list of   expressions which are iterated over. <li><code>statement: Statement</code>: The statement which returns the data.</li> <p>The data of <code>comprehensionExpressions[i]</code> flow to <code>comprehensionExpressions[i+1]</code> and the last item in <code>comprehensionExpressions</code> flows to <code>statement</code>.</p> <p>Scheme: <pre><code>  flowchart LR\n    comp[\"for all 0 &lt;= i &lt; comprehensionExpressions-1: comprehensionExpressions[i]\"] -- DFG --&gt; comp1[\"comprehensionExpressions[i+1]\"]  -- DFG --&gt; stmt[\"statement\"] -- DFG --&gt; node([CollectionComprehension]);\n    node -.- comp;\n    node -.- comp1;\n    node -.- stmt;</code></pre></p>"},{"location":"CPG/specs/dfg/#collectioncomprehensioncomprehensionexpression","title":"CollectionComprehension.ComprehensionExpression","text":"<p>Interesting fields:</p> <ul> <li><code>predicates: List&lt;Statements&gt;</code>: A list of conditions which have to hold to   process the variable in the result.</li> <li><code>iterable: Statement</code>: The statement which iterates over something.</li> <li><code>variable: Statement</code>: The variable which holds the individual elements in the   iterable.</li> </ul> <p>The data of <code>iterable</code> flow to <code>variable</code> which flows to the whole node. Also, all <code>predicates</code> flow to the whole node.</p> <p>Scheme: <pre><code>  flowchart LR\n    pred[\"for all i: predicates[i]\"]  -- DFG --&gt; stmt[\"statement\"] -- DFG --&gt; node([CollectionComprehension.ComprehensionExpression]);\n    iterable[\"iterable\"] -- DFG --&gt; var[\"variable\"];\n    var -- DFG --&gt; node;\n    node -.- pred;\n    node -.- var;\n    node -.- iterable;</code></pre></p> <p>Implicit Dataflows</p> <p>The DFG does not model implicit dataflows, i.e., the information if the execution or some conditions may have an impact on certain variables, the program's behavior. This information can easily be found in the program dependence graph (PDG).</p>"},{"location":"CPG/specs/dfg/#conditionalexpression","title":"ConditionalExpression","text":"<p>Interesting fields:</p> <ul> <li><code>condition: Expression</code>: The condition which is evaluated.</li> <li><code>thenExpression: Expression</code>: The expression which is executed if the   condition holds.</li> <li><code>elseExpression: Expression</code>: The expression which is executed if the   condition does not hold.</li> </ul> <p>The <code>thenExpr</code> and the <code>elseExpr</code> flow to the <code>ConditionalExpression</code>. This means that implicit data flows are not considered.</p> <p>Scheme:   <pre><code>flowchart LR\n  thenExpression -- DFG --&gt; node([ConditionalExpression]);\n  thenExpression -.- node;\n  elseExpression -.- node;\n  elseExpression -- DFG --&gt; node;</code></pre></p> <p>Implicit Dataflows</p> <p>The DFG does not model implicit dataflows, i.e., the information if the execution or some conditions may have an impact on certain variables, the program's behavior. This information can easily be found in the program dependence graph (PDG).</p>"},{"location":"CPG/specs/dfg/#reference","title":"Reference","text":"<p>Interesting fields:</p> <ul> <li><code>refersTo: Declaration</code>: The declaration e.g. of the variable or symbol.</li> <li><code>access: AccessValues</code>: Determines if the value is read from, written to or   both.</li> </ul> <p>This is the most tricky concept for the DFG edges. We have to differentiate between the DFG edges generated by the <code>DFGPass</code> and the ones generated by the <code>ControlFlowSensitiveDFGPass</code>.</p> <p>The <code>DFGPass</code> generates very simple edges based on the access to the variable as follows:</p> <ul> <li>The value flows from the declaration to the expression for read access.   Scheme:   <pre><code>flowchart LR\n  refersTo -- DFG --&gt; node([Reference]);\n  refersTo -.- node;</code></pre></li> <li>For write access, data flow from the expression to the declaration. Scheme:   <pre><code>flowchart LR\n  node([Reference]) -- DFG --&gt; refersTo;\n  node -.- refersTo;</code></pre></li> <li>For readwrite access, both flows are present. Scheme:   <pre><code>flowchart LR\n  refersTo -- DFG 1 --&gt; node([Reference]);\n  refersTo -.- node;\n  node -- DFG 2 --&gt; refersTo;</code></pre></li> </ul> <p>This mostly serves one purpose: The current function pointer resolution requires such flows. Once the respective passes are redesigned, we may want to update this.</p> <p>The <code>ControlFlowSensitiveDFGPass</code> completely changes this behavior and accounts for the data flows which differ depending on the program's control flow (e.g., different assignments to a variable in an if and else branch, ...). The pass performs the following actions:</p> <ul> <li>First, it clears all the edges between a <code>VariableDeclaration</code> and its   <code>Reference</code>. Actually, it clears all incoming and outgoing DFG edges of all   VariableDeclarations in a function. This includes the initializer but this   edge is restored right away. Scheme:   <pre><code>flowchart LR\n  node([VariableDeclaration]) -.- initializer;\n  initializer -- DFG --&gt; node;</code></pre></li> <li>For each read access to a Reference, it collects all potential previous   assignments to the variable and adds these to the incoming DFG edges. You can   imagine that this is done by traversing the EOG backwards until finding the   first assignment to the variable for each possible path. Scheme:   <pre><code>flowchart LR\n  node([Reference]) -.- refersTo;\n  A == last write to ==&gt; refersTo;\n  A[/Node/] -- DFG --&gt; node;</code></pre></li> <li>If we increment or decrement a variable with \"++\" or \"--\", the data of this   statement flows from the previous writes of the variable to the input of the   statement (= the Reference). We write back to this reference and consider the   lhs as a \"write\" to the variable! Attention: This potentially adds loops and   can look like a branch. Needs to be handled with care in subsequent   passes/analyses! Scheme:   <pre><code>flowchart LR\n  node([UnaryOperator]) -.- input;\n  input -.- |\"(optional)\"| refersTo;\n  W -- DFG 1 --&gt; input;\n  W[/Node/] == last write to ==&gt; refersTo;\n  input -- DFG 2 --&gt; node;\n  node -- DFG 3 --&gt; input;\n  input -- DFG 4 --&gt; R[/Node/];\n  R == next read of ==&gt; refersTo;</code></pre></li> <li>For compound operators such as <code>+=, -=, *=, /=</code>, we have an incoming flow from   the last writes to reference on the left hand side of the expression to the   lhs. The lhs then flows to the whole expression. Also, the right hand side   flows to the whole expression (if it's a read, this is processed separately).   The data flows back to the lhs which is marked as the last write to the   variable. Attention: This potentially adds loops and can look like a branch.   Needs to be handled with care in subsequent passes/analyses! Scheme:   <pre><code>flowchart LR\n  node -.- rhs;\n  node -.- lhs;\n  lhs -.- refersTo;\n  W -- DFG 1 --&gt; lhs;\n  W[/Node/] == last write to ==&gt; refersTo;\n  rhs -- DFG 2 --&gt; node;\n  lhs -- DFG 4 --&gt; R;\n  lhs -- DFG 2 --&gt; node([BinaryOperator]);\n  node -- DFG 3 --&gt; lhs;\n  R[/Node/] == next read of ==&gt; refersTo;</code></pre></li> <li>If the variable is assigned a value (a binary operator <code>var = rhs</code>), the right   hand side flows to the variable. This is considered as a write operation.   Scheme:   <pre><code>flowchart LR \n  node -.- rhs;\n  node -.- lhs;\n  lhs -.- refersTo;\n  lhs -- DFG 2 --&gt; node([BinaryOperator]);\n  R[/Node/] == next read of ==&gt; refersTo;\n  rhs -- DFG --&gt; lhs;\n  lhs -- DFG --&gt; refersTo</code></pre></li> </ul>"},{"location":"CPG/specs/dfg/#memberexpression","title":"MemberExpression","text":"<p>Interesting fields:</p> <ul> <li><code>base: Expression</code>: The base object whose field is accessed.</li> <li><code>refersTo: Declaration?</code>: The field it refers to. If the class is not   implemented in the code under analysis, it is <code>null</code>.</li> </ul> <p>The MemberExpression represents an access to an object's field and extends a Reference with a <code>base</code></p> <p>If an implementation of the respective class is available, we handle it like a normal Reference. If the <code>refersTo</code> field is <code>null</code> (i.e., the implementation is not available), base flows to the expression.</p>"},{"location":"CPG/specs/dfg/#expressionlist","title":"ExpressionList","text":"<p>Interesting fields:</p> <ul> <li><code>expressions: List&lt;Statement&gt;</code></li> </ul> <p>The data of the last statement in <code>expressions</code> flows to the expression.</p>"},{"location":"CPG/specs/dfg/#initializerlistexpression","title":"InitializerListExpression","text":"<p>Interesting fields:</p> <ul> <li><code>initializers: List&lt;Expression&gt;</code>: The list of expressions which initialize the   values.</li> </ul> <p>The data of all initializers flow to this expression.</p> <p>Scheme: <pre><code>  flowchart LR\n    inits[\"for all i: initializers[i]\"] -- DFG --&gt; node([InitializerListExpression]);\n    node -.- inits;</code></pre></p>"},{"location":"CPG/specs/dfg/#keyvalueexpression","title":"KeyValueExpression","text":"<p>Interesting fields:</p> <ul> <li><code>value: Expression</code>: The value which is assigned.</li> </ul> <p>The value flows to this expression.</p> <p>Scheme: <pre><code>  flowchart LR\n    value -- DFG --&gt; node([KeyValueExpression]);\n    value -.- node;</code></pre></p>"},{"location":"CPG/specs/dfg/#lambdaexpression","title":"LambdaExpression","text":"<p>Interesting fields:</p> <ul> <li><code>function: FunctionDeclaration</code>: The usage of a lambda</li> </ul> <p>The data flow from the function representing the lambda to the expression.</p> <p>Scheme: <pre><code>  flowchart LR\n    function -- DFG --&gt; node([LambdaExpression]);\n    function -.- node;</code></pre></p>"},{"location":"CPG/specs/dfg/#unaryoperator","title":"UnaryOperator","text":"<p>Interesting fields:</p> <ul> <li><code>input: Expression</code>: The inner expression</li> <li><code>operatorCode: String</code>: A string representation of the operation</li> </ul> <p>The data flow from the input to this node and, in case of the operatorCodes ++ and -- also back from the node to the input.</p> <pre><code>  flowchart TD\n    node1([UnaryOperator]) -.- operator\n    operator ==&gt; cmp\n\n    cmp == \"operator == '++' ||\n     operator == '--'\" ==&gt; incdec;\n\n    cmp == \"operator != '++' &amp;&amp;\n     operator != '--'\" ==&gt; finish[ ];\n\n    subgraph finish[ ]\n      node2([UnaryOperator]) -.- input2;\n      input2 -.- |\"(optional)\"| refersTo2;\n      W2[/Node/] == last write to ==&gt; refersTo2;\n      W2 -- DFG 1 --&gt; input2[input];\n      input2 -- DFG 2 --&gt; node2;\n    end\n\n    subgraph incdec[ ]\n      node([UnaryOperator]) -.- input;\n      input -.- |\"(optional)\"| refersTo;\n      W[/Node/] == last write to ==&gt; refersTo;\n      W -- DFG 1 --&gt; input;\n      input -- DFG 2 --&gt; node;\n      node -- DFG 3 --&gt; input;\n      input -- DFG 4 --&gt; R[/Node/];\n      R == next read of ==&gt; refersTo;\n    end</code></pre> <p>Dangerous: We have to ensure that the first operation is performed before the last one (if applicable).</p>"},{"location":"CPG/specs/dfg/#throwexpression","title":"ThrowExpression","text":"<p>Interesting fields:</p> <ul> <li><code>exception: Expression</code>: The exception which is thrown.</li> <li><code>parentException: Expression</code>: The exception which has originally caused this   exception to be thrown (e.g. in a catch clause).</li> </ul> <p>The return value flows to the whole statement.</p> <p>Scheme: <pre><code>  flowchart LR\n    exception -- DFG --&gt; node([ThrowExpression]);\n    parentException -- DFG --&gt; node;\n    exception -.- node;\n    parentException -.- node;</code></pre></p>"},{"location":"CPG/specs/dfg/#returnstatement","title":"ReturnStatement","text":"<p>Interesting fields:</p> <ul> <li><code>returnValue: Expression</code>: The value which is returned</li> </ul> <p>The return value flows to the whole statement.</p> <p>Scheme: <pre><code>  flowchart LR\n    returnValue -- DFG --&gt; node([ReturnStatement]);\n    returnValue -.- node;</code></pre></p>"},{"location":"CPG/specs/dfg/#branching-statements","title":"Branching Statements","text":"<p>Specific statements lead to a branch in the control flow of a program. A value that influences the branching decision can lead to an implicit data flow via the branching, and we therefore draw a dfg edge from the condition, to the branching node.</p> <p>Implicit Dataflows</p> <p>The DFG does not model implicit dataflows, i.e., the information if the execution or some conditions may have an impact on certain variables, the program's behavior. This information can easily be found in the program dependence graph (PDG).</p>"},{"location":"CPG/specs/dfg/#foreachstatement","title":"ForEachStatement","text":"<p>Interesting fields:</p> <ul> <li><code>variable: Statement</code>: The statement which is used in each iteration to assign   the current iteration value.</li> <li><code>iterable: Statement</code>: The statement or expression, which is iterated.</li> </ul> <p>The value of the iterable flow to the <code>VariableDeclaration</code> in the <code>variable</code>. Since some languages allow arbitrary logic, we differentiate between two cases:</p>"},{"location":"CPG/specs/dfg/#case-1-the-variable-is-a-declarationstatement","title":"Case 1. The <code>variable</code> is a <code>DeclarationStatement</code>.","text":"<p>This is the case for most languages where we can have only a variable in this place (e.g., <code>for(e in list)</code>). Here, we get the declaration(s) in the statement and add the DFG from the iterable to this declaration.</p> <p>Scheme: <pre><code>  flowchart LR\n    node([ForEachStatement]) -.- variable[variable: DeclarationStatement]\n    node -.- iterable[iterable]\n    variable -.- declarations[\"declarations[i]\"]\n    iterable -- for all i: DFG --&gt; declarations</code></pre></p>"},{"location":"CPG/specs/dfg/#case-2-the-variable-is-another-type-of-statement","title":"Case 2. The <code>variable</code> is another type of <code>Statement</code>.","text":"<p>In this case, we assume that the last VariableDeclaration is the one used for looping. We add a DFG edge only to this declaration.</p> <p>Scheme: <pre><code>  flowchart LR\n    node([ForEachStatement]) -.- statement[variable]\n    node -.- iterable[iterable]\n    statement -.- localVars[variables]\n    localVars -. \"last\" .-&gt; variable\n    iterable -- DFG --&gt; variable\n    variable -- DFG --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#dostatement","title":"DoStatement","text":"<p>Interesting fields:</p> <ul> <li><code>condition: Statement</code>: The condition that is evaluated before making the   branching decision.</li> </ul> <p>Scheme: <pre><code>  flowchart LR\n    node([DoStatement]) -.- condition(condition)\n    condition -- DFG --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#whilestatement","title":"WhileStatement","text":"<p>Interesting fields:</p> <ul> <li><code>condition: Statement</code>: The condition that is evaluated before making the   branching decision.</li> <li><code>conditionDeclaration: Statement</code>: A declaration containing the condition in   the initializer, used instead of the condition.</li> </ul> <p>Scheme: <pre><code>  flowchart LR\n    node([WhileStatement]) -.- condition(condition)\n    node -.- conditionDeclaration(conditionDeclaration)\n    condition -- DFG --&gt; node\n    conditionDeclaration  -- DFG --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#forstatement","title":"ForStatement","text":"<p>Interesting fields:</p> <ul> <li><code>condition: Statement</code>: The condition that is evaluated before making the   branching decision.</li> <li><code>conditionDeclaration: Statement</code>: A declaration containing the condition in   the initializer, used instead of the condition.</li> </ul> <p>Scheme: <pre><code>  flowchart LR\n    node([ForStatement]) -.- condition(condition)\n    node -.- conditionDeclaration(conditionDeclaration)\n    condition -- DFG --&gt; node\n    conditionDeclaration  -- DFG --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#ifstatement","title":"IfStatement","text":"<p>Interesting fields:</p> <ul> <li><code>condition: Statement</code>: The condition that is evaluated before making the   branching decision.</li> <li><code>conditionDeclaration: Statement</code>: A declaration with an initializer   containing the condition which can be used instead of the condition.</li> </ul> <p>Scheme: <pre><code>  flowchart LR\n    node([IfStatement]) -.- condition(condition)\n    node -.- conditionDeclaration(conditionDeclaration)\n    condition -- DFG --&gt; node\n    conditionDeclaration  -- DFG --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#switchstatement","title":"SwitchStatement","text":"<p>Interesting fields:</p> <ul> <li><code>selector: Statement</code>: The expression that is evaluated before making the   branching decision.</li> <li><code>selectorDeclaration: Statement</code>: A declaration containing the selector in the   initializer, used instead of the selector.</li> </ul> <p>Scheme: <pre><code>  flowchart LR\n    node([SwitchStatement]) -.- selector(selector)\n    node -.- selectorDeclaration(selectorDeclaration)\n    selector -- DFG --&gt; node\n    selectorDeclaration  -- DFG --&gt; node</code></pre></p>"},{"location":"CPG/specs/dfg/#functiondeclaration","title":"FunctionDeclaration","text":"<p>Interesting fields:</p> <ul> <li><code>body: Expression</code>: The body (i.e., all statements) of the function   implementation.</li> </ul> <p>The values of all return expressions in the body flow to the function declaration.</p> <p>Scheme: <pre><code>  flowchart LR\n    returns -- DFG --&gt; node([FunctionDeclaration]);\n    body -.- node;\n    body -.- |in all statements| returns[\"returns: ReturnStatement\"]</code></pre></p>"},{"location":"CPG/specs/dfg/#fielddeclaration","title":"FieldDeclaration","text":"<p>Interesting fields:</p> <ul> <li><code>initializer: Expression?</code>: The value which is used to initialize a field (if   applicable).</li> </ul> <p>The value of the initializer flows to the whole field.</p> <p>In addition, all writes to a reference to the field (via a <code>Reference</code>) flow to the field, for all reads, data flow to the reference.</p> <p>Scheme: <pre><code>  flowchart LR\n    initializer -- DFG --&gt; node([FieldDeclaration]);\n    initializer -.- node;\n    node -- DFG --&gt; R[/Node/];\n    R == next read of ==&gt; node;</code></pre></p>"},{"location":"CPG/specs/dfg/#variabledeclaration","title":"VariableDeclaration","text":"<p>Interesting fields:</p> <ul> <li><code>initializer: Expression?</code>: The value which is used to initialize a variable</li> <li>(if applicable).</li> </ul> <p>The value of the initializer flows to the variable declaration. The value of the variable declarations flows to all <code>References</code> which read the value before the value of the variable is written to through another reference to the variable.</p> <p>Scheme: <pre><code>  flowchart LR\n    initializer -- DFG --&gt; node([VariableDeclaration]);\n    initializer -.- node;\n    node -- DFG --&gt; R[/Node/];\n    R == next read of ==&gt; node;</code></pre></p>"},{"location":"CPG/specs/dfg/#tupledeclaration","title":"TupleDeclaration","text":"<p>Interesting fields:</p> <ul> <li><code>initializer: Expression?</code>: The value which is used to initialize a variable   (if applicable).</li> <li><code>element: List&lt;VariableDeclaration&gt;</code>: The value which is used to initialize a   variable (if applicable).</li> </ul> <p>The value of the initializer flows to the elements of the tuple declaration. The value of the variable declarations flows to all <code>References</code> which read the value before the value of the variable is written to through another reference to the variable.</p> <p>Scheme: <pre><code>  flowchart LR\n    initializer -- \"for all i: DFG[i]\" --&gt; tuple(\"elements[i]\");\n    node([VariableDeclaration]) -.- tuple;\n    initializer -.- node;\n    tuple -- DFG --&gt; R[/Node/];\n    R == next read of ==&gt; tuple;</code></pre></p>"},{"location":"CPG/specs/dfg/#assignment","title":"Assignment","text":"<p>Interesting fields:</p> <ul> <li><code>value: Expression</code>: The rhs of the assignment.</li> <li><code>target: AssignmentTarget</code>: The lhs of the assignment.</li> </ul> <p>This should already be covered by the declarations and binary operator \"=\". If not, the <code>value</code> flows to the <code>target</code>.</p> <p>Scheme: <pre><code>  flowchart LR\n    value -.- node([Assignment]);\n    target -.- node;\n    value -- DFG --&gt; target;</code></pre></p>"},{"location":"CPG/specs/eog/","title":"Specification: Evaluation Order Graph","text":"<p>The Evaluation Order Graph (EOG) is built as edges between AST nodes after the initial translation of the code to the CPG. Its purpose is to follow the order in which code is executed, similar to a CFG, and additionally differentiate on a finer level of granularity in which order expressions and subexpressions are evaluated. Every node points to a set of previously evaluated nodes (<code>prevEOG</code>) and nodes that are evaluated after (<code>nextEOG</code>). The EOG edges are intra-procedural and thus differentiate from INVOKES edges. In the following, we summarize in which order the root node representing a language construct and its descendants in the AST tree are connected.</p> <p>An EOG always starts at root node representing a method/function or record that holds executable code and ends in the node representing the corresponding code or multiple return statements. An implicit return statement with a code location of (-1,-1) is used if the actual source code does not have an explicit return statement.</p> <p>A distinct EOG is drawn for any declared component that can contain code, currently: <code>NamespaceDeclaration</code>, <code>TranslationUnitDeclaration</code>, <code>RecordDeclaration</code> and any subclass of <code>FunctionDeclaration</code>.</p> <p>The EOG is similar to a CFG which connects basic blocks of statements, but there are some subtle differences:</p> <ul> <li>For methods without explicit return statement, the EOG will have an edge to a virtual return node  with line number -1 which does not exist in the original code.    A CFG will always end with the last reachable statement(s) and not insert any virtual return statements.</li> <li>The EOG considers an opening blocking (<code>Block</code>, indicated by a <code>{</code>) as a separate node.   A CFG will rather use the first actual executable statement within the block.</li> <li>For IF statements, the EOG treats the <code>if</code> keyword and the condition as separate nodes.   A CFG treats this as one <code>if</code> statement.</li> <li>The EOG considers a method header as a node.   A CFG will consider the first executable statement of the methods as a node.</li> </ul>"},{"location":"CPG/specs/eog/#general-structure","title":"General Structure","text":"<p>The graphs in this specification abstract the representation of the handled graph, to formally specify how EOG edges are drawn between a parent node and the subgraphs rooted by its children. Therefore, a collection of AST children are represented as abstract nodes showing the multiplicity of the node with an indicator (n), in case of sets, or as several nodes showing how the position in a list can impact the construction of an EOG, e.g., nodes (i - 1) to i. The EOG is constructed as postorder of the AST traversal. When building the EOG for the expression a + b, the entire expression is considered evaluated after the subexpression a and the subexpression b is evaluated, therefore EOG edges connect nodes of (a) and (b) before reaching the parent node (+).</p> <p>Note: Nodes describing the titled programing construct will be drawn round, while the rectangular nodes represent their abstract children, that can be atomic leaf nodes or deep AST subtrees. EOG edges to these abstract nodes always mean that a subtree expansion would be necessary to connect the target of the EOG edge to the right node in the subtree.</p> <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; lhs\n  node --EOG--&gt; next:::outer\n  node([+]) -.-&gt; lhs[\"a\"]\n  node -.-&gt; rhs[\"b\"]\n  lhs --EOG--&gt; rhs\n  rhs --EOG--&gt; node</code></pre> <p>Whether a subgraph (a) or (b) is connected first, depends on the exact construct and sometimes the language that is translated into a CPG. Note that, in the following graphics we will often draw an EOG edge to an abstract child node of a language construct that is an AST subtree. The EOG path through that subtree will depend on the node types of that tree and mostly start connecting one of the AST leaf nodes.</p>"},{"location":"CPG/specs/eog/#functiondeclaration","title":"FunctionDeclaration","text":"<p>A function declaration is the start of an intra-procedural EOG and contains its end. Therefore, there is no incoming or outgoing edge to <code>previous</code> or <code>next</code> eog nodes that are not in its AST subtree. The EOG connects the code body, as well as the default values of parameters if they exist.</p> <p>Interesting fields:</p> <ul> <li><code>parameters: List&lt;ParameterDeclaration&gt;</code>: The parameters of the function.</li> <li><code>defaultValue: Expression</code>: Optional default values of the parameters that have to be evaluated before executing the function's body.</li> <li><code>body: Statement</code>: One or multiple statements executed when this function is called.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  parent([\"FunctionDeclaration\"]) --EOG--&gt;child1[\"defaultValue(i-1)\"]\n  child1 --EOG--&gt;child2[\"defaultValue(i)\"]\n  child2  --EOG--&gt; body\n  parent -.-&gt; body\n  parent -.\"parameters(n)\".-&gt;child3[\"parameter(i-1)\"] -.-&gt;child1 \n  parent -.\"parameters(n)\".-&gt;child4[\"parameter(i)\"] -.-&gt;child2</code></pre></p>"},{"location":"CPG/specs/eog/#statementholder","title":"StatementHolder","text":"<p>StatementHolder is an interface for any node that is not a function and contains code that should be connected with an EOG. The following classes implement this interface: <code>NamespaceDeclaration</code>, <code>TranslationUnitDeclaration</code>, <code>RecordDeclaration</code> and <code>Block</code>. The Node implementing the interface is the start of one or multiple EOGs. Note that code inside such a holder can be static or non-static (bound to an instance of a record). Therefore, two separate EOGs may be built. </p> <p>Interesting fields:</p> <ul> <li><code>statements: List&lt;Statement&gt;</code>: The code inside a holder. The individual elements are distinguished by a property marking them as <code>staticBlock</code> if they are a <code>Block</code>.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  holder([StatementHolder])-.\"statements(n)\".-&gt;sblock1[\"StaticStatement(i-1)\"]\n  holder([StatementHolder])-.\"statements(n)\".-&gt;sblock2[\"StaticStatement(i)\"]\n  holder-.\"statements(n)\".-&gt;nblock1[\"NonStaticStatement(i-1)\"]\n  holder-.\"statements(n)\".-&gt;nblock2[\"NonStaticStatement(i)\"]\n  holder--EOG--&gt;sblock1\n  sblock1--EOG--&gt;sblock2\n  holder--EOG--&gt;nblock1\n  nblock1--EOG--&gt;nblock2</code></pre></p>"},{"location":"CPG/specs/eog/#tupledeclaration","title":"TupleDeclaration","text":"<p>Represents the declaration of a tuple of variables.</p> <p>Interesting fields:</p> <ul> <li><code>initializer: Expression</code>: The result of evaluation will initialize the variable.</li> <li><code>elements: List&lt;VariableDeclaration&gt;</code>: The result of evaluation will initialize the variable.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child\n  parent([\"TupleDeclaration\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child[\"initializer\"]\n  child --EOG--&gt; e0[\"elements[0]\"]\n  e0 --EOG--&gt; e.[\"...\"]\n  e. --EOG--&gt; ei[\"elements[i]\"]\n  ei --EOG--&gt; parent\n</code></pre></p>"},{"location":"CPG/specs/eog/#variabledeclaration","title":"VariableDeclaration","text":"<p>Represents the declaration of a local or global variable.</p> <p>Interesting fields:</p> <ul> <li><code>initializer: Expression</code>: The result of evaluation will initialize the variable.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent([\"VariableDeclaration\"])\n  child --EOG--&gt; next:::outer\n  parent -.-&gt; child[\"initializer\"]\n  parent --EOG--&gt; child</code></pre></p> <p>In case the variable is a global variable (e.g., a top-level variable in a <code>RecordDeclaration</code>), it does not have a <code>prevEOG</code> and the initializer does not have a <code>nextEOG</code>.</p>"},{"location":"CPG/specs/eog/#callexpression","title":"CallExpression","text":"<p>Represents any type of call in a program.</p> <p>Interesting fields:</p> <ul> <li><code>callee: Expression</code>: The expression declaring the target of a call. This can be a base in a <code>MemberCallExpression</code> or a function pointer in a <code>CallExpression</code>or a reference.</li> <li><code>arguments: List&lt;Expression&gt;</code>: Mapped to the parameters of the call target but evaluated before the call happens.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child[\"callee\"]\n  parent([\"CallExpression\"]) --EOG--&gt; next:::outer\n  child --EOG--&gt; arg1[\"Argument(i-1)\"]\n  arg1--EOG--&gt; arg2[\"Argument(i)\"]\n  arg2[\"Argument(i)\"] --EOG--&gt; parent\n  parent -.-&gt; child\n  parent -.\"arguments(n)\".-&gt; arg1\n  parent -.\"arguments(n)\".-&gt; arg2</code></pre></p>"},{"location":"CPG/specs/eog/#memberexpression","title":"MemberExpression","text":"<p>Access to the field in a <code>RecordDeclaration</code>.</p> <p>Interesting fields:</p> <ul> <li><code>base: Expression</code>: The base evaluated to determine whose field we want to access.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child\n  parent([\"MemberExpression\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child[\"base\"]\n  child --EOG--&gt; parent</code></pre></p>"},{"location":"CPG/specs/eog/#subscriptexpression","title":"SubscriptExpression","text":"<p>Array access in the form of <code>arrayExpression[subscriptExpression]</code>.</p> <p>Interesting fields:</p> <ul> <li><code>arrayExpression: Expression</code>: The array to be accessed.</li> <li><code>subscriptExpression: Expression</code>: The index in the array.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child\n  child --EOG--&gt; child2[\"subscriptExpression\"]\n  parent([\"SubscriptExpression\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child[\"arrayExpression\"]\n  parent -.-&gt; child2\n  child2 --EOG--&gt; parent</code></pre></p>"},{"location":"CPG/specs/eog/#newarrayexpression","title":"NewArrayExpression","text":"<p>Interesting fields:</p> <ul> <li><code>dimensions: List&lt;Expression&gt;</code>: Multiple expressions that define the array's dimensions.</li> <li><code>initializer: Expression</code>: The expression for array initialization.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"dimension(i-1)\"]\n  child1 --EOG--&gt; child2[\"dimension(i)\"]\n  child2 --EOG--&gt; initializer\n  parent([\"NewArrayExpression\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child1\n  parent -.-&gt; child2\n  parent -.-&gt; initializer\n  initializer --EOG--&gt; parent</code></pre></p>"},{"location":"CPG/specs/eog/#keyvalueexpression","title":"KeyValueExpression","text":"<p>Represents a key / value pair that could be used in associative arrays, among others.</p> <p>Interesting fields:</p> <ul> <li><code>key: Expression</code>: The key used for later accessing this pair.</li> <li><code>value: Expression</code>: The value of the pair.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child\n  child --EOG--&gt; child2[\"value\"]\n  parent([\"KeyValueExpression\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child[\"key\"]\n  parent -.-&gt; child2\n  child2 --EOG--&gt; parent</code></pre></p>"},{"location":"CPG/specs/eog/#declarationstatement","title":"DeclarationStatement","text":"<p>Here, the EOG is only drawn to the child component if that component is a VariableDeclaration, not if it is a FunctionDeclaration.</p> <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child\n  parent([\"DeclarationStatement\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child([\"VariableDeclaration\"])\n  child --EOG--&gt; parent\n</code></pre>"},{"location":"CPG/specs/eog/#returnstatement","title":"ReturnStatement","text":"<p>This forms the end of an EOG as this is the last statement to be executed in the function.</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child\n  child[\"returnValue\"] --EOG--&gt; parent([\"ReturnStatement\"])\n  parent -.-&gt; child</code></pre></p>"},{"location":"CPG/specs/eog/#binaryoperator","title":"BinaryOperator","text":"<p>Interesting fields:</p> <ul> <li><code>lhs: Expression</code>: Left hand side of a binary operation.</li> <li><code>rhs: Expression</code>: Right hand side of a binary operation.</li> <li><code>operatorCode: String</code>: The operation.</li> </ul> <p>We differentiate between two cases based on the <code>operatorCode</code>.</p>"},{"location":"CPG/specs/eog/#short-circuit-evaluation","title":"Short-circuit evaluation","text":"<p>The operations <code>&amp;&amp;</code> and <code>||</code> have a short-circuit evaluation. This means that the expression can terminate early if the <code>lhs</code> is false (for <code>&amp;&amp;</code>) or <code>true</code> (for <code>||</code>). This affects the EOG by adding an EOG edge from <code>lhs</code> to the BinaryOperator.</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; lhs\n  node --EOG--&gt; next:::outer\n  node([BinaryOperator]) -.-&gt; lhs\n  node -.-&gt; rhs\n  lhs --EOG--&gt; rhs\n  lhs --EOG--&gt; node\n  rhs --EOG--&gt; node</code></pre></p>"},{"location":"CPG/specs/eog/#default-case","title":"Default case","text":"<p>For the other binary operations like <code>+</code>, <code>-</code> but also assignments <code>=</code> and <code>+=</code> we follow the left before right order. The <code>lhs</code> is evaluated before the <code>rhs</code> as we assume left to right evaluation.</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; lhs\n  node --EOG--&gt; next:::outer\n  node([BinaryOperator]) -.-&gt; lhs\n  node -.-&gt; rhs\n  lhs --EOG--&gt; rhs\n  rhs --EOG--&gt; node</code></pre></p>"},{"location":"CPG/specs/eog/#assignexpression","title":"AssignExpression","text":"<p>Interesting fields:</p> <ul> <li><code>lhs: List&lt;Expression&gt;</code>: All expressions on the left-hand side of the assignment (i.e., the target)</li> <li><code>rhs: List&lt;Expression&gt;</code>: All expressions on the right-hand side of the assignment (i.e., the value to be assigned)</li> <li><code>declarations: List&lt;Declaration&gt;</code>: All expressions on the left-hand side of the assignment (i.e., the target)</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; decl0[\"declarations[0]\"]\n  decl0 --EOG--&gt; decl.[\"...\"]\n  decl. --EOG--&gt; decli[\"declarations[i]\"]\n  decli --EOG--&gt; lhs0[\"lhs[0]\"]\n  lhs0 --EOG--&gt; lhs.[\"...\"]\n  lhs. --EOG--&gt; lhsi[\"lhs[i]\"]\n  lhsi--EOG--&gt; rhs0[\"rhs[0]\"]\n  rhs0 --EOG--&gt; rhs.[\"...\"]\n  rhs. --EOG--&gt; rhsi[\"rhs[i]\"]\n  rhsi --EOG--&gt; node</code></pre></p>"},{"location":"CPG/specs/eog/#block","title":"Block","text":"<p>Represents an explicit block of statements.</p> <p>Interesting fields:</p> <ul> <li><code>statements:List&lt;Statement&gt;</code>: Statements in a block of code that are evaluated sequentially.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"statement(i-1)\"]\n  child1 --EOG--&gt;child2[\"statement(i)\"]\n  parent([\"Block\"]) --EOG--&gt; next:::outer\n  parent -.\"statements(n)\".-&gt; child1\n  parent -.\"statements(n)\".-&gt; child2\n  child2 --EOG--&gt; parent\n</code></pre></p>"},{"location":"CPG/specs/eog/#unaryoperator","title":"UnaryOperator","text":"<p>For unary operations like <code>!</code> but also writing operations: <code>++</code> and <code>--</code>.</p> <p>Interesting fields:</p> <ul> <li><code>input:Expression</code>: Wrapped by the unary operation.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child[\"input\"]\n  child --EOG--&gt;parent\n  parent([\"UnaryOperator\"]) --EOG--&gt; next:::outer\n  parent -.\"statements(n)\".-&gt; child</code></pre></p>"},{"location":"CPG/specs/eog/#throwexpression","title":"ThrowExpression","text":"<p>The EOG continues at an exception catching structure or a function that does a re-throw.</p> <p>Interesting fields:</p> <ul> <li><code>exception: Expression</code>: Exception to be thrown for exception handling.</li> <li><code>parentException: Expression</code>: Exception which caused this exception to be thrown.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"exception\"]\n  child1 --EOG--&gt; child2[\"parentException\"]\n  child2 --EOG--&gt;parent\n  parent([\"ThrowExpression\"]) --EOG--&gt; catchingContext:::outer\n  parent -.-&gt; child1\n  parent -.-&gt; child2</code></pre></p>"},{"location":"CPG/specs/eog/#assertstatement","title":"AssertStatement","text":"<p>Statement that evaluates a condition and if the condition is false, evaluates a message, this message is generalized to a <code>Statement</code> to hold everything  from a single String, to an Exception construction.</p> <p>Interesting fields:</p> <ul> <li><code>condition: Expression</code> Its evaluation leads to evaluation of message and EOG termination or to the regular evaluation of the parent <code>AssertStatement</code>.</li> <li><code>message: Statement</code>: A String message or Exception evaluated only if the assertion fails. </li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"condition\"]\n  child1 --\"EOG:false\"--&gt;child2[\"message\"]\n  child1 --\"EOG:true\"--&gt;parent\n  parent([AssertStatement]) --EOG--&gt; next:::outer\n  parent -.-&gt; child1\n  parent -.-&gt; child2\n</code></pre></p>"},{"location":"CPG/specs/eog/#trystatement","title":"TryStatement","text":"<p>After the execution of the statement the control flow only proceeds with the next statement if all exceptions were handled. If not, execution is relayed to the next outer exception handling context.</p> <p>Interesting fields:</p> <ul> <li><code>resources:List&lt;Statement&gt;</code>: Initialization of values needed in the block or special objects needing cleanup.</li> <li><code>tryBlock:Block</code>: The code that should be tried, exceptions inside lead to an eog edge to the catch clauses.</li> <li><code>finallyBlock:Block</code>: All EOG paths inside the <code>tryBlock</code> or the <code>catch</code> blocks will finally reach this block and evaluate it.</li> <li><code>catchBlocks:List&lt;Block&gt;</code>: Children of <code>CatchClause</code> (omitted here), evaluated when the exception matches the clauses condition.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer -- EOG --&gt; resource[\"resource(i-1)\"];\n  resource -.- parent\n  resource -- EOG --&gt; resourceI[\"resource(i)\"]\n  resourceI -.- parent\n  resourceI -- EOG --&gt; try[\"tryBlock\"]\n  try -.- parent\n  throws:::outer -- EOG --&gt; catch[\"catchBlock(i)\"]\n  try -- EOG --&gt; finally[\"finallyBlock\"]\n  parent([TryStatement]) --EOG--&gt; next:::outer\n  parent --EOG--&gt; catchingContext:::outer\n  catch -- EOG --&gt; finally\n  finally -- EOG --&gt; parent\n  finally -.- parent\n  catch -.- parent</code></pre></p>"},{"location":"CPG/specs/eog/#continuestatement","title":"ContinueStatement","text":"<p>The execution continues at the <code>condition</code> of a node associated to a <code>Continuable</code> scope, e.g. <code>WhileStatement</code>. This is not necessarily the closest enclosing node of this type, the <code>ContinueStatement</code> may contain a label specifying the exact outer node.</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent\n  parent([\"ContinueStatement\"]) --EOG--&gt; conditionInContinuableContext:::outer\n</code></pre></p>"},{"location":"CPG/specs/eog/#breakstatement","title":"BreakStatement","text":"<p>The execution continues after a node associated to a <code>Breakable</code> scope, e.g. <code>WhileStatement</code>or <code>SwitchStatement</code>. This is not necessarily the closest enclosing node of this type, the <code>BreakStatement</code> may contain a label specifying the exact outer node.</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent\n  parent([\"BreakStatement\"]) --EOG--&gt; nextAfterBreakableContext:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#deleteexpression","title":"DeleteExpression","text":"<p>Deletion of a specific object freeing memory or calling the destructor.</p> <p>Interesting fields:</p> <ul> <li><code>operand: Expression</code>: The result of the evaluation is the object to be deleted.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child[\"operand\"]\n  child --EOG--&gt; parent\n  parent([\"DeleteExpression\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child</code></pre></p>"},{"location":"CPG/specs/eog/#labelstatement","title":"LabelStatement","text":"<p>The <code>LabelStatement</code> itself is not added to the EOG. EOG construction is directly forwarded to the labeled statement in the <code>subStatement</code>.</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child[\"subStatement\"]\n  child --EOG--&gt; next:::outer\n  parent([\"LabelStatement\"]) -.-&gt; child</code></pre></p>"},{"location":"CPG/specs/eog/#gotostatement","title":"GotoStatement","text":"<p>Models a <code>goto</code>statement and an EOG-Edge is created to the appropriate <code>LabelStatement</code>.</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child([\"GotoStatement\"])\n  child --EOG--&gt; labeledStatement:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#newexpression","title":"NewExpression","text":"<p>Creates a new object, which is either an array or an instantiation of a <code>RecordDeclaration</code>. The initializer has to be evaluated to create the object.</p> <p>Interesting fields:</p> <ul> <li><code>initializer: Expression</code>: To be evaluated before creating a new object.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child[\"initializer\"]\n  child --EOG--&gt; parent\n  parent([\"NewExpression\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child</code></pre></p>"},{"location":"CPG/specs/eog/#castexpression","title":"CastExpression","text":"<p>Interesting fields:</p> <ul> <li><code>expression: Expression</code>: An expression of a specific compile time type, cast to a specified other compile time type.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child[\"expression\"]\n  child --EOG--&gt; parent\n  parent([\"CastExpression\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child</code></pre></p>"},{"location":"CPG/specs/eog/#expressionlist","title":"ExpressionList","text":"<p>List of several expressions that are evaluated sequentially. The resulting value is the last evaluated expression.</p> <p>Interesting fields:</p> <ul> <li><code>expressions: List&lt;Expression&gt;</code>: Several expressions in sequential order.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"expression(i-1)\"]\n  child1 --EOG--&gt; child2[\"expression(i)\"]\n  child2 --EOG--&gt; parent\n  parent([\"ExpressionList\"]) --EOG--&gt; next:::outer\n  parent -.\"expressions(n)\".-&gt; child1\n  parent -.\"expressions(n)\".-&gt; child2</code></pre></p>"},{"location":"CPG/specs/eog/#initializerlistexpression","title":"InitializerListExpression","text":"<p>This expression initializes multiple variables or an object of multiple elements, e.g. arrays, lists.</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"initializer(i-1)\"]\n  child1 --EOG--&gt; child2[\"initializer(i)\"]\n  child2 --EOG--&gt; parent\n  parent([\"InitializerListExpression\"]) --EOG--&gt; next:::outer\n  parent -.\"initializers(n)\".-&gt; child1\n  parent -.\"initializers(n)\".-&gt; child2</code></pre></p>"},{"location":"CPG/specs/eog/#constructexpression","title":"ConstructExpression","text":"<p>A ConstructExpression creates an object.</p> <p>Interesting fields:</p> <ul> <li><code>arguments: List&lt;Expression&gt;</code>: Arguments to the construction, e.g. arguments for a call to a constructor.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"argument(i-1)\"]\n  child1 --EOG--&gt; child2[\"argument(i)\"]\n  child2 --EOG--&gt; parent\n  parent([\"ConstructExpression\"]) --EOG--&gt; next:::outer\n  parent -.\"arguments(n)\".-&gt; child1\n  parent -.\"arguments(n)\".-&gt; child2</code></pre></p>"},{"location":"CPG/specs/eog/#synchronizedstatement","title":"SynchronizedStatement","text":"<p>The placement of the root node between expression and executed block is such that algorithms can be evaluated the expression and then encountering the information that this expression is used for synchronization.</p> <p>Interesting fields:</p> <ul> <li><code>expression: Expression</code>: Its evaluation returns an object that acts as a lock for synchronization.</li> <li><code>block: Block</code>: Code executed while the object evaluated from <code>expression</code> is locked.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"expression\"]\n  child1 --EOG--&gt; parent\n  parent --EOG--&gt; child2[\"block\"]\n  child2 --EOG--&gt; next:::outer\n  parent -.-&gt; child1\n  parent -.-&gt; child2</code></pre></p>"},{"location":"CPG/specs/eog/#conditionalexpression","title":"ConditionalExpression","text":"<p>A conditional evaluation of two expression, realizing the branching pattern of an <code>IfStatement</code> on the expression level.</p> <p>Interesting fields:</p> <ul> <li><code>condition:Expression</code>: Executed first to decide the branch of evaluation.</li> <li><code>thenExpression:Expression</code>: Evaluated if <code>condition</code> evaluates to <code>true.</code></li> <li><code>elseExpression:Expression</code>: Evaluated if <code>condition</code> evaluates to <code>false.</code></li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"condition\"]\n  child1 --EOG--&gt; parent([\"ConditionalExpression\"])\n  parent --EOG:true--&gt; child2[\"thenExpression\"]\n  parent --EOG:false--&gt; child3[\"elseExpression\"]\n  child2 --EOG--&gt; next:::outer\n  child3 --EOG--&gt; next:::outer\n  parent -.-&gt; child1\n  parent -.-&gt; child2\n  parent -.-&gt; child3</code></pre></p>"},{"location":"CPG/specs/eog/#collectioncomprehension","title":"CollectionComprehension","text":"<p>This node iterates through a collection of elements via <code>comprehensionExpression</code> and applies <code>statement</code> to the elements. </p> <p>Interesting fields:</p> <ul> <li><code>comprehensionExpressions: List&lt;ComprehensionExpression&gt;</code>: The part which iterates through all elements of the collection and filter them.</li> <li><code>statement: Statement</code>: The operation applied to each element iterated over.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"comprehensionExpressions[0]\"]\n  child1 --EOG:true--&gt; child2[\"comprehensionExpressions[n]\"]\n  child2 --EOG:true--&gt; child3[\"statement\"]\n  child2 --EOG:false--&gt; child1[\"comprehensionExpressions[0]\"]\n  child1 --EOG:false--&gt; parent([\"CollectionComprehension\"])\n  child3 --EOG--&gt; child2\n  parent --EOG--&gt; next:::outer\n  parent -.-&gt; child3\n  parent -.-&gt; child2\n  parent -.-&gt; child1</code></pre></p>"},{"location":"CPG/specs/eog/#comprehensionexpression","title":"ComprehensionExpression","text":"<p>This node iterates through a collection of elements of <code>iterable</code>, keeps the element in <code>variable</code> and evaluates an optional <code>predicate</code>.</p> <p>Interesting fields:</p> <ul> <li><code>iterable: Statement</code>: The part which iterates through all elements of the collection (or similar).</li> <li><code>variable: Statement</code>: The variable holding each element in the iterable.</li> <li><code>predicate: Statement</code>: A condition which determines if we consider this variable further or if we fetch the next element.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"iterable\"]\n  child1 --EOG:true--&gt; child2[\"variable\"]\n  child2 --EOG--&gt; child3[\"predicate\"]\n  child3 --EOG--&gt; parent([\"ComprehensionExpression\"])\n  parent --EOG:true--&gt; enter:::outer\n  parent --EOG:false--&gt; child1\n  child1 --EOG:false--&gt; exit:::outer\n  parent -.-&gt; child3\n  parent -.-&gt; child2\n  parent -.-&gt; child1</code></pre></p>"},{"location":"CPG/specs/eog/#whilestatement","title":"WhileStatement","text":"<p>This is a classic while loop where the condition is evaluated before every loop iteration.</p> <p>Note: The condition may be enclosed in a declaration, in that case the EOG will not contain a <code>condition</code> but rather a declaration of a variable where the <code>initializer</code> serves as loop condition. Uses of one or the other are currently mutually exclusive.</p> <p>Interesting fields:</p> <ul> <li><code>condition: Expression</code>: The condition for the loop.</li> <li><code>conditionDeclaration: Declaration</code>: The declaration of a variable with condition as initializer.</li> <li><code>statement: Statement</code>: The body of the loop to be iterated over.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"condition|conditionDeclaration\"]\n  child1 --EOG--&gt; parent\n  parent --EOG:false--&gt; next:::outer\n  parent([\"WhileStatement\"]) --EOG:true--&gt; child3[\"statement\"]\n  child3 --EOG--&gt; child1\n  parent -.-&gt; child1\n  parent -.-&gt; child3</code></pre></p>"},{"location":"CPG/specs/eog/#dostatement","title":"DoStatement","text":"<p>This is a classic do while loop where the condition is evaluated after every loop iteration.</p> <p>Interesting fields:</p> <ul> <li><code>condition: Expression</code>: The condition of the loop.</li> <li><code>statement: Statement</code>: The body of the loop to be iterated over.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"statement\"];\n  child1 --EOG--&gt; child2[\"condition\"];\n  child2 --EOG--&gt; parent([\"DoStatement\"]);\n  parent --EOG:false--&gt; next:::outer\n  parent --EOG:true--&gt; child1\n  parent -.-&gt; child1\n  parent -.-&gt; child2</code></pre></p>"},{"location":"CPG/specs/eog/#foreachstatement","title":"ForEachStatement","text":"<p>This is a loop that iterates over all elements in a multi-element <code>iterable</code> with the single elements bound to the declaration of <code>variable</code> while evaluating <code>statement</code>.</p> <p>Interesting fields:</p> <ul> <li><code>iterable: Statement</code>: Elements of this iterable will trigger a loop iteration.</li> <li><code>variable: Statement</code>: Variable declaring Statement that binds elements to a name.</li> <li><code>statement: Statement</code>: Loop body to be iterated over.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"iterable\"]\n  child1 --EOG--&gt; child2[\"variable\"]\n  child2 --EOG--&gt; parent\n  parent --EOG:false--&gt; next:::outer\n  parent([\"ForEachStatement\"]) --EOG:true--&gt; child3[\"statement\"]\n  child3 --EOG--&gt; child1\n  parent -.-&gt; child2\n  parent -.-&gt; child1\n  parent -.-&gt; child3</code></pre></p>"},{"location":"CPG/specs/eog/#forstatement","title":"ForStatement","text":"<p>This is a classic for-loop where a statement is executed before the loop run, a condition is evaluated before every loop iteration, and a post iteration statement can be declared.</p> <p>Note: The condition may be enclosed in a declaration. In this case, the EOG will not contain a <code>condition</code> but rather a declaration of a variable where the <code>initializer</code> serves as loop condition. Uses of one or the other are currently mutually exclusive.</p> <p>Interesting fields:</p> <ul> <li><code>initializerStatement:Statement</code>: Statement run once, before the loop starts.</li> <li><code>condition: Expression</code>: The condition of the loop.</li> <li><code>conditionDeclaration: Declaration</code>: The declaration of a variable with the condition as initializer.</li> <li><code>statement: Statement</code>: The body of the loop to be iterated over.</li> <li><code>iterationStatement: Statement</code>: The statement to be executed after each loop iteration.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  iteration --EOG--&gt; condition\n  statement --EOG--&gt; iteration[\"iterationStatement\"]\n  prev:::outer --EOG--&gt; initializer[\"initializerStatement\"]\n  parent --EOG:false--&gt; next:::outer\n  initializer --EOG--&gt; condition[\"condition|conditionDeclaration\"]\n  condition --EOG--&gt; parent\n  parent([\"ForStatement\"]) --EOG:true--&gt; statement[\"statement\"]</code></pre></p>"},{"location":"CPG/specs/eog/#ifstatement","title":"IfStatement","text":"<p>This is a branching statement where the evaluation of a <code>condition</code> leads to the execution of one optional, or two mutually exclusive blocks of code.</p> <p>Note: The condition may be enclosed in a declaration, in that case the EOG will not contain a <code>condition</code> but rather a declaration of a variable where the <code>initializer</code> serves as branching condition. Uses of one or the other are currently mutually exclusive.</p> <p>Interesting fields:</p> <ul> <li><code>condition: Expression</code>: The condition of the branching decision.</li> <li><code>conditionDeclaration: Declaration</code>: The declaration of a variable with condition as initializer.</li> <li><code>thenStatement: Statement</code>: The body of the mandatory block that is evaluated if the <code>condition</code> evaluates to <code>true</code>.</li> <li><code>elseStatement: Statement</code>: The body of an optional block that is evaluated if the <code>condition</code> evaluates to <code>false</code>.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"initializerStatement\"]\n  child1 --EOG--&gt; child2[\"condition|conditionDeclaration\"]\n  child2 --EOG--&gt; parent\n  parent([\"IfStatement\"]) --EOG:true--&gt; child4[\"thenStatement\"]\n  parent --EOG:false--&gt; child5[\"elseStatement\"]\n  parent --EOG--&gt; next:::outer\n  child4 --EOG--&gt; next:::outer\n  child5 --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#switchstatement","title":"SwitchStatement","text":"<p>This is a switch statement where the evaluation of a <code>selector</code> decides the entry point in a large block of code. <code>CaseStatements</code> serve as entry points and <code>BreakStatements</code> are needed to prevent all cases after the entry to be evaluated.</p> <p>Note: The <code>selector</code> may be enclosed in a declaration. In this case, the EOG will not contain a selector but rather a declaration of a variable where the <code>initializer</code> serves as switch selector. Uses of one or the other are currently mutually exclusive.</p> <p>Interesting fields:</p> <ul> <li><code>selector: Expression</code>: The evaluated selector which needs to match the expression evaluation of the expression in a <code>caseStatement</code> or the entry will be the <code>defaultStatement</code>.</li> <li><code>selectorDeclaration: Declaration</code>: The declarations <code>initializer</code> serves as <code>selector</code>.</li> <li><code>statement: Statement</code>: The body containing all entry points and statements to be executed.</li> <li><code>caseStatement: Statement</code>: The entry point into the evaluation of the switch body if the <code>selector</code> matches its <code>caseExpression</code>.</li> <li><code>defaultStatement: Statement</code>: The default entry point if no <code>caseExpression</code> matched the selector.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child1[\"initializerStatement\"]\n  child1 --EOG--&gt; child2[\"selector|selectorDeclaration\"]\n  child2 --EOG--&gt; parent\n  parent([\"SwitchStatement\"]) --EOG--&gt; child4[\"caseStatement\"]\n  parent --EOG--&gt; child5[\"defaultStatement\"]\n  child7[\"statement(n-1)\"] --EOG--&gt; child6[\"statement\"]\n  parent -.-&gt;child6\n  child6 -.\"statements(n)\".-&gt; child4\n  child6 -.\"statements(n)\".-&gt; child5\n  child6 -.\"statements(n)\".-&gt; child7\n  child6 --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#casestatement","title":"CaseStatement","text":"<p>Serves as an entry point inside a <code>SwitchStatement</code>, the statements executed after entry are not children of this structure but can be found on the same AST hierarchy level. </p> <p>Interesting fields:</p> <ul> <li><code>caseExpression: Expression</code>: serves as an entry point if its evaluation matches the <code>selector</code> evaluation in <code>SwitchStatement</code></li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; child[\"caseExpression\"]\n  child --EOG--&gt; parent\n  parent([\"CaseStatement\"]) --EOG--&gt; next:::outer\n  parent -.-&gt; child\n</code></pre></p>"},{"location":"CPG/specs/eog/#lambdaexpression","title":"LambdaExpression","text":"<p>The expression itself is connected to the outer EOG. A separate EOG is built for the expressed code, as the code itself is not executed at this point.</p> <p>Interesting fields:</p> <ul> <li><code>function: FunctionDeclaration</code>: The function declared by the lambda that can be executed at different points in the program.</li> </ul> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent[\"LambdaExpression\"]\n  parent --EOG--&gt; next:::outer\n  parent -.-&gt; child\n  child([\"function\"]) --EOG--&gt;internalNext:::outer\n</code></pre></p>"},{"location":"CPG/specs/eog/#typeexpression","title":"TypeExpression","text":"<p>The expression itself is connected to the outer EOG.</p> <p>Interesting fields: /</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent[\"TypeExpression\"]\n  parent --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#lookupscopestatement","title":"LookupScopeStatement","text":"<p>The statement itself is connected to the outer EOG.</p> <p>Interesting fields: /</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent[\"LookupScopeStatement\"]\n  parent --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#emptystatement","title":"EmptyStatement","text":"<p>The statement itself is connected to the outer EOG.</p> <p>Interesting fields: /</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent[\"EmptyStatement\"]\n  parent --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#literal","title":"Literal","text":"<p>The statement itself is connected to the outer EOG.</p> <p>Interesting fields: /</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent[\"Literal\"]\n  parent --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#defaultstatement","title":"DefaultStatement","text":"<p>The statement itself is connected to the outer EOG.</p> <p>Interesting fields: /</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent[\"DefaultStatement\"]\n  parent --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#typeidexpression","title":"TypeIdExpression","text":"<p>The statement itself is connected to the outer EOG.</p> <p>Interesting fields: /</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent[\"TypeIdExpression\"]\n  parent --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#reference","title":"Reference","text":"<p>The statement itself is connected to the outer EOG.</p> <p>Interesting fields: /</p> <p>Scheme: <pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;\n  prev:::outer --EOG--&gt; parent[\"Reference\"]\n  parent --EOG--&gt; next:::outer</code></pre></p>"},{"location":"CPG/specs/eog/#includedeclaration","title":"IncludeDeclaration","text":"<p>The <code>IncludeDeclaration</code> is not connected to the EOG. We continue with the next statement.</p>"},{"location":"CPG/specs/graph/","title":"Graph Schema","text":""},{"location":"CPG/specs/graph/#cpg-schema","title":"CPG Schema","text":"<p>This file shows all node labels and relationships between them that are persisted from the in memory CPG to the Neo4j database. The specification is generated automatically and always up to date.</p>"},{"location":"CPG/specs/graph/#node","title":"Node","text":""},{"location":"CPG/specs/graph/#children","title":"Children","text":"<p>Statement Declaration Type Scope OverlayNode AnnotationMember Annotation Component</p>"},{"location":"CPG/specs/graph/#relationships","title":"Relationships","text":"<p>ADDITIONAL_PROBLEMS EOG CDG DFG ANNOTATIONS PDG AST SCOPE</p>"},{"location":"CPG/specs/graph/#additional_problems","title":"ADDITIONAL_PROBLEMS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNode--\"ADDITIONAL_PROBLEMS*\"--&gt;NodeADDITIONAL_PROBLEMS[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#eog","title":"EOG","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNode--\"EOG\u00b9\"--&gt;NodeEOG[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#cdg","title":"CDG","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNode--\"CDG\u00b9\"--&gt;NodeCDG[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#dfg","title":"DFG","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNode--\"DFG\u00b9\"--&gt;NodeDFG[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#annotations","title":"ANNOTATIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNode--\"ANNOTATIONS\u00b9\"--&gt;NodeANNOTATIONS[&lt;a href='#eannotation'&gt;Annotation&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#pdg","title":"PDG","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNode--\"PDG\u00b9\"--&gt;NodePDG[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#ast","title":"AST","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNode--\"AST*\"--&gt;NodeAST[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#scope","title":"SCOPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNode--\"SCOPE\u00b9\"--&gt;NodeSCOPE[&lt;a href='#escope'&gt;Scope&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties","title":"Properties","text":"<p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#statement","title":"Statement","text":"<p>Labels:Node Statement</p>"},{"location":"CPG/specs/graph/#children_1","title":"Children","text":"<p>AssertStatement LoopStatement Expression CaseStatement ReturnStatement LabelStatement EmptyStatement IfStatement CatchClause SwitchStatement GotoStatement ContinueStatement DefaultStatement SynchronizedStatement TryStatement BreakStatement LookupScopeStatement DeclarationStatement</p>"},{"location":"CPG/specs/graph/#relationships_1","title":"Relationships","text":"<p>LOCALS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#locals","title":"LOCALS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nStatement--\"LOCALS\u00b9\"--&gt;StatementLOCALS[&lt;a href='#evaluedeclaration'&gt;ValueDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_1","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#assertstatement","title":"AssertStatement","text":"<p>Labels:Node Statement AssertStatement</p>"},{"location":"CPG/specs/graph/#relationships_2","title":"Relationships","text":"<p>MESSAGE CONDITION</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#message","title":"MESSAGE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nAssertStatement--\"MESSAGE\u00b9\"--&gt;AssertStatementMESSAGE[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#condition","title":"CONDITION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nAssertStatement--\"CONDITION\u00b9\"--&gt;AssertStatementCONDITION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_2","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#loopstatement","title":"LoopStatement","text":"<p>Labels:Node Statement LoopStatement</p>"},{"location":"CPG/specs/graph/#children_2","title":"Children","text":"<p>DoStatement ForStatement WhileStatement ForEachStatement</p>"},{"location":"CPG/specs/graph/#relationships_3","title":"Relationships","text":"<p>ELSE_STATEMENT STATEMENT</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#else_statement","title":"ELSE_STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nLoopStatement--\"ELSE_STATEMENT\u00b9\"--&gt;LoopStatementELSE_STATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#statement_1","title":"STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nLoopStatement--\"STATEMENT\u00b9\"--&gt;LoopStatementSTATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_3","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#dostatement","title":"DoStatement","text":"<p>Labels:Node Statement LoopStatement DoStatement</p>"},{"location":"CPG/specs/graph/#relationships_4","title":"Relationships","text":"<p>CONDITION</p> Inherited Relationships <p>ELSE_STATEMENT</p> <p>STATEMENT</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#condition_1","title":"CONDITION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nDoStatement--\"CONDITION\u00b9\"--&gt;DoStatementCONDITION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_4","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#forstatement","title":"ForStatement","text":"<p>Labels:Node Statement LoopStatement ForStatement</p>"},{"location":"CPG/specs/graph/#relationships_5","title":"Relationships","text":"<p>CONDITION_DECLARATION CONDITION ITERATION_STATEMENT INITIALIZER_STATEMENT</p> Inherited Relationships <p>ELSE_STATEMENT</p> <p>STATEMENT</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#condition_declaration","title":"CONDITION_DECLARATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nForStatement--\"CONDITION_DECLARATION\u00b9\"--&gt;ForStatementCONDITION_DECLARATION[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#condition_2","title":"CONDITION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nForStatement--\"CONDITION\u00b9\"--&gt;ForStatementCONDITION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#iteration_statement","title":"ITERATION_STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nForStatement--\"ITERATION_STATEMENT\u00b9\"--&gt;ForStatementITERATION_STATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#initializer_statement","title":"INITIALIZER_STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nForStatement--\"INITIALIZER_STATEMENT\u00b9\"--&gt;ForStatementINITIALIZER_STATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_5","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#whilestatement","title":"WhileStatement","text":"<p>Labels:Node Statement LoopStatement WhileStatement</p>"},{"location":"CPG/specs/graph/#relationships_6","title":"Relationships","text":"<p>CONDITION_DECLARATION CONDITION</p> Inherited Relationships <p>ELSE_STATEMENT</p> <p>STATEMENT</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#condition_declaration_1","title":"CONDITION_DECLARATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nWhileStatement--\"CONDITION_DECLARATION\u00b9\"--&gt;WhileStatementCONDITION_DECLARATION[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#condition_3","title":"CONDITION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nWhileStatement--\"CONDITION\u00b9\"--&gt;WhileStatementCONDITION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_6","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#foreachstatement","title":"ForEachStatement","text":"<p>Labels:Node Statement LoopStatement ForEachStatement</p>"},{"location":"CPG/specs/graph/#relationships_7","title":"Relationships","text":"<p>ITERABLE VARIABLE</p> Inherited Relationships <p>ELSE_STATEMENT</p> <p>STATEMENT</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#iterable","title":"ITERABLE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nForEachStatement--\"ITERABLE\u00b9\"--&gt;ForEachStatementITERABLE[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#variable","title":"VARIABLE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nForEachStatement--\"VARIABLE\u00b9\"--&gt;ForEachStatementVARIABLE[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_7","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#expression","title":"Expression","text":"<p>Labels:Node Statement Expression</p>"},{"location":"CPG/specs/graph/#children_3","title":"Children","text":"<p>CallExpression NewExpression UnaryOperator CollectionComprehension ThrowExpression Block CastExpression Reference BinaryOperator ConditionalExpression DeleteExpression SubscriptExpression ProblemExpression RangeExpression LambdaExpression NewArrayExpression KeyValueExpression AssignExpression ComprehensionExpression TypeExpression InitializerListExpression Literal TypeIdExpression ExpressionList</p>"},{"location":"CPG/specs/graph/#relationships_8","title":"Relationships","text":"<p>TYPE ASSIGNED_TYPES</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#type","title":"TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nExpression--\"TYPE\u00b9\"--&gt;ExpressionTYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#assigned_types","title":"ASSIGNED_TYPES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nExpression--\"ASSIGNED_TYPES*\"--&gt;ExpressionASSIGNED_TYPES[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_8","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#callexpression","title":"CallExpression","text":"<p>Labels:Node Statement Expression CallExpression</p>"},{"location":"CPG/specs/graph/#children_4","title":"Children","text":"<p>OperatorCallExpression ConstructExpression MemberCallExpression</p>"},{"location":"CPG/specs/graph/#relationships_9","title":"Relationships","text":"<p>CALLEE INVOKES TEMPLATE_INSTANTIATION TEMPLATE_ARGUMENTS ARGUMENTS</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#callee","title":"CALLEE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCallExpression--\"CALLEE\u00b9\"--&gt;CallExpressionCALLEE[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#invokes","title":"INVOKES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCallExpression--\"INVOKES\u00b9\"--&gt;CallExpressionINVOKES[&lt;a href='#efunctiondeclaration'&gt;FunctionDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#template_instantiation","title":"TEMPLATE_INSTANTIATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCallExpression--\"TEMPLATE_INSTANTIATION\u00b9\"--&gt;CallExpressionTEMPLATE_INSTANTIATION[&lt;a href='#etemplatedeclaration'&gt;TemplateDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#template_arguments","title":"TEMPLATE_ARGUMENTS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCallExpression--\"TEMPLATE_ARGUMENTS\u00b9\"--&gt;CallExpressionTEMPLATE_ARGUMENTS[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#arguments","title":"ARGUMENTS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCallExpression--\"ARGUMENTS\u00b9\"--&gt;CallExpressionARGUMENTS[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_9","title":"Properties","text":"<p>template : boolean</p> Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#operatorcallexpression","title":"OperatorCallExpression","text":"<p>Labels:Node Statement Expression CallExpression OperatorCallExpression</p>"},{"location":"CPG/specs/graph/#relationships_10","title":"Relationships","text":"Inherited Relationships <p>CALLEE</p> <p>INVOKES</p> <p>TEMPLATE_INSTANTIATION</p> <p>TEMPLATE_ARGUMENTS</p> <p>ARGUMENTS</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_10","title":"Properties","text":"<p>operatorCode : String</p> Inherited Properties <p>template : boolean</p> <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#constructexpression","title":"ConstructExpression","text":"<p>Labels:Node Statement Expression CallExpression ConstructExpression</p>"},{"location":"CPG/specs/graph/#relationships_11","title":"Relationships","text":"<p>INSTANTIATES ANONYMOUS_CLASS CONSTRUCTOR</p> Inherited Relationships <p>CALLEE</p> <p>INVOKES</p> <p>TEMPLATE_INSTANTIATION</p> <p>TEMPLATE_ARGUMENTS</p> <p>ARGUMENTS</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#instantiates","title":"INSTANTIATES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nConstructExpression--\"INSTANTIATES\u00b9\"--&gt;ConstructExpressionINSTANTIATES[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#anonymous_class","title":"ANONYMOUS_CLASS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nConstructExpression--\"ANONYMOUS_CLASS\u00b9\"--&gt;ConstructExpressionANONYMOUS_CLASS[&lt;a href='#erecorddeclaration'&gt;RecordDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#constructor","title":"CONSTRUCTOR","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nConstructExpression--\"CONSTRUCTOR\u00b9\"--&gt;ConstructExpressionCONSTRUCTOR[&lt;a href='#econstructordeclaration'&gt;ConstructorDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_11","title":"Properties","text":"Inherited Properties <p>template : boolean</p> <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#membercallexpression","title":"MemberCallExpression","text":"<p>Labels:Node Statement Expression CallExpression MemberCallExpression</p>"},{"location":"CPG/specs/graph/#relationships_12","title":"Relationships","text":"Inherited Relationships <p>CALLEE</p> <p>INVOKES</p> <p>TEMPLATE_INSTANTIATION</p> <p>TEMPLATE_ARGUMENTS</p> <p>ARGUMENTS</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_12","title":"Properties","text":"<p>isStatic : boolean</p> Inherited Properties <p>template : boolean</p> <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#newexpression","title":"NewExpression","text":"<p>Labels:Node Statement Expression NewExpression</p>"},{"location":"CPG/specs/graph/#relationships_13","title":"Relationships","text":"<p>INITIALIZER TEMPLATE_PARAMETERS</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#initializer","title":"INITIALIZER","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNewExpression--\"INITIALIZER\u00b9\"--&gt;NewExpressionINITIALIZER[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#template_parameters","title":"TEMPLATE_PARAMETERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNewExpression--\"TEMPLATE_PARAMETERS\u00b9\"--&gt;NewExpressionTEMPLATE_PARAMETERS[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_13","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#unaryoperator","title":"UnaryOperator","text":"<p>Labels:Node Statement Expression UnaryOperator</p>"},{"location":"CPG/specs/graph/#relationships_14","title":"Relationships","text":"<p>INPUT</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#input","title":"INPUT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nUnaryOperator--\"INPUT\u00b9\"--&gt;UnaryOperatorINPUT[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_14","title":"Properties","text":"<p>operatorCode : String</p> <p>isPostfix : boolean</p> <p>isPrefix : boolean</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#collectioncomprehension","title":"CollectionComprehension","text":"<p>Labels:Node Statement Expression CollectionComprehension</p>"},{"location":"CPG/specs/graph/#relationships_15","title":"Relationships","text":"<p>COMPREHENSION_EXPRESSIONS STATEMENT</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#comprehension_expressions","title":"COMPREHENSION_EXPRESSIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCollectionComprehension--\"COMPREHENSION_EXPRESSIONS\u00b9\"--&gt;CollectionComprehensionCOMPREHENSION_EXPRESSIONS[&lt;a href='#ecomprehensionexpression'&gt;ComprehensionExpression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#statement_2","title":"STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCollectionComprehension--\"STATEMENT\u00b9\"--&gt;CollectionComprehensionSTATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_15","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#throwexpression","title":"ThrowExpression","text":"<p>Labels:Node Statement Expression ThrowExpression</p>"},{"location":"CPG/specs/graph/#relationships_16","title":"Relationships","text":"<p>PARENT_EXCEPTION EXCEPTION</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#parent_exception","title":"PARENT_EXCEPTION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nThrowExpression--\"PARENT_EXCEPTION\u00b9\"--&gt;ThrowExpressionPARENT_EXCEPTION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#exception","title":"EXCEPTION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nThrowExpression--\"EXCEPTION\u00b9\"--&gt;ThrowExpressionEXCEPTION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_16","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#block","title":"Block","text":"<p>Labels:Node Statement Expression Block</p>"},{"location":"CPG/specs/graph/#children_5","title":"Children","text":"<p>DistinctLanguageBlock</p>"},{"location":"CPG/specs/graph/#relationships_17","title":"Relationships","text":"<p>STATEMENTS</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#statements","title":"STATEMENTS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nBlock--\"STATEMENTS\u00b9\"--&gt;BlockSTATEMENTS[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_17","title":"Properties","text":"<p>isStaticBlock : boolean</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#distinctlanguageblock","title":"DistinctLanguageBlock","text":"<p>Labels:Node Statement Expression Block DistinctLanguageBlock</p>"},{"location":"CPG/specs/graph/#relationships_18","title":"Relationships","text":"Inherited Relationships <p>STATEMENTS</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_18","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>isStaticBlock : boolean</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#castexpression","title":"CastExpression","text":"<p>Labels:Node Statement Expression CastExpression</p>"},{"location":"CPG/specs/graph/#relationships_19","title":"Relationships","text":"<p>CAST_TYPE EXPRESSION</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#cast_type","title":"CAST_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCastExpression--\"CAST_TYPE\u00b9\"--&gt;CastExpressionCAST_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#expression_1","title":"EXPRESSION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCastExpression--\"EXPRESSION\u00b9\"--&gt;CastExpressionEXPRESSION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_19","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#reference","title":"Reference","text":"<p>Labels:Node Statement Expression Reference</p>"},{"location":"CPG/specs/graph/#children_6","title":"Children","text":"<p>MemberExpression</p>"},{"location":"CPG/specs/graph/#relationships_20","title":"Relationships","text":"<p>REFERS_TO ALIASES RESOLUTION_HELPER CANDIDATES</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#refers_to","title":"REFERS_TO","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nReference--\"REFERS_TO\u00b9\"--&gt;ReferenceREFERS_TO[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#aliases","title":"ALIASES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nReference--\"ALIASES*\"--&gt;ReferenceALIASES[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#resolution_helper","title":"RESOLUTION_HELPER","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nReference--\"RESOLUTION_HELPER\u00b9\"--&gt;ReferenceRESOLUTION_HELPER[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#candidates","title":"CANDIDATES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nReference--\"CANDIDATES*\"--&gt;ReferenceCANDIDATES[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_20","title":"Properties","text":"<p>access : AccessValues</p> <p>isStaticAccess : boolean</p> Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#memberexpression","title":"MemberExpression","text":"<p>Labels:Node Statement Expression Reference MemberExpression</p>"},{"location":"CPG/specs/graph/#relationships_21","title":"Relationships","text":"<p>BASE</p> Inherited Relationships <p>REFERS_TO</p> <p>ALIASES</p> <p>RESOLUTION_HELPER</p> <p>CANDIDATES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#base","title":"BASE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nMemberExpression--\"BASE\u00b9\"--&gt;MemberExpressionBASE[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_21","title":"Properties","text":"<p>operatorCode : String</p> Inherited Properties <p>access : AccessValues</p> <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>isStaticAccess : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#binaryoperator","title":"BinaryOperator","text":"<p>Labels:Node Statement Expression BinaryOperator</p>"},{"location":"CPG/specs/graph/#children_7","title":"Children","text":"<p>ShortCircuitOperator</p>"},{"location":"CPG/specs/graph/#relationships_22","title":"Relationships","text":"<p>RHS LHS</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#rhs","title":"RHS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nBinaryOperator--\"RHS\u00b9\"--&gt;BinaryOperatorRHS[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#lhs","title":"LHS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nBinaryOperator--\"LHS\u00b9\"--&gt;BinaryOperatorLHS[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_22","title":"Properties","text":"<p>operatorCode : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#shortcircuitoperator","title":"ShortCircuitOperator","text":"<p>Labels:Node Statement Expression BinaryOperator ShortCircuitOperator</p>"},{"location":"CPG/specs/graph/#relationships_23","title":"Relationships","text":"Inherited Relationships <p>RHS</p> <p>LHS</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_23","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>operatorCode : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#conditionalexpression","title":"ConditionalExpression","text":"<p>Labels:Node Statement Expression ConditionalExpression</p>"},{"location":"CPG/specs/graph/#relationships_24","title":"Relationships","text":"<p>THEN_EXPRESSION CONDITION ELSE_EXPRESSION</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#then_expression","title":"THEN_EXPRESSION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nConditionalExpression--\"THEN_EXPRESSION\u00b9\"--&gt;ConditionalExpressionTHEN_EXPRESSION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#condition_4","title":"CONDITION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nConditionalExpression--\"CONDITION\u00b9\"--&gt;ConditionalExpressionCONDITION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#else_expression","title":"ELSE_EXPRESSION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nConditionalExpression--\"ELSE_EXPRESSION\u00b9\"--&gt;ConditionalExpressionELSE_EXPRESSION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_24","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#deleteexpression","title":"DeleteExpression","text":"<p>Labels:Node Statement Expression DeleteExpression</p>"},{"location":"CPG/specs/graph/#relationships_25","title":"Relationships","text":"<p>OPERANDS</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#operands","title":"OPERANDS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nDeleteExpression--\"OPERANDS\u00b9\"--&gt;DeleteExpressionOPERANDS[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_25","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#subscriptexpression","title":"SubscriptExpression","text":"<p>Labels:Node Statement Expression SubscriptExpression</p>"},{"location":"CPG/specs/graph/#relationships_26","title":"Relationships","text":"<p>ARRAY_EXPRESSION SUBSCRIPT_EXPRESSION</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#array_expression","title":"ARRAY_EXPRESSION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSubscriptExpression--\"ARRAY_EXPRESSION\u00b9\"--&gt;SubscriptExpressionARRAY_EXPRESSION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#subscript_expression","title":"SUBSCRIPT_EXPRESSION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSubscriptExpression--\"SUBSCRIPT_EXPRESSION\u00b9\"--&gt;SubscriptExpressionSUBSCRIPT_EXPRESSION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_26","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#problemexpression","title":"ProblemExpression","text":"<p>Labels:Node Statement Expression ProblemExpression</p>"},{"location":"CPG/specs/graph/#relationships_27","title":"Relationships","text":"Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_27","title":"Properties","text":"<p>problem : String</p> <p>problemType : ProblemType</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#rangeexpression","title":"RangeExpression","text":"<p>Labels:Node Statement Expression RangeExpression</p>"},{"location":"CPG/specs/graph/#relationships_28","title":"Relationships","text":"<p>FLOOR CEILING THIRD</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#floor","title":"FLOOR","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRangeExpression--\"FLOOR\u00b9\"--&gt;RangeExpressionFLOOR[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#ceiling","title":"CEILING","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRangeExpression--\"CEILING\u00b9\"--&gt;RangeExpressionCEILING[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#third","title":"THIRD","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRangeExpression--\"THIRD\u00b9\"--&gt;RangeExpressionTHIRD[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_28","title":"Properties","text":"<p>operatorCode : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#lambdaexpression","title":"LambdaExpression","text":"<p>Labels:Node Statement Expression LambdaExpression</p>"},{"location":"CPG/specs/graph/#relationships_29","title":"Relationships","text":"<p>MUTABLE_VARIABLES FUNCTION</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#mutable_variables","title":"MUTABLE_VARIABLES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nLambdaExpression--\"MUTABLE_VARIABLES*\"--&gt;LambdaExpressionMUTABLE_VARIABLES[&lt;a href='#evaluedeclaration'&gt;ValueDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#function","title":"FUNCTION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nLambdaExpression--\"FUNCTION\u00b9\"--&gt;LambdaExpressionFUNCTION[&lt;a href='#efunctiondeclaration'&gt;FunctionDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_29","title":"Properties","text":"<p>areVariablesMutable : boolean</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#newarrayexpression","title":"NewArrayExpression","text":"<p>Labels:Node Statement Expression NewArrayExpression</p>"},{"location":"CPG/specs/graph/#relationships_30","title":"Relationships","text":"<p>INITIALIZER DIMENSIONS</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#initializer_1","title":"INITIALIZER","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNewArrayExpression--\"INITIALIZER\u00b9\"--&gt;NewArrayExpressionINITIALIZER[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#dimensions","title":"DIMENSIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNewArrayExpression--\"DIMENSIONS\u00b9\"--&gt;NewArrayExpressionDIMENSIONS[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_30","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#keyvalueexpression","title":"KeyValueExpression","text":"<p>Labels:Node Statement Expression KeyValueExpression</p>"},{"location":"CPG/specs/graph/#relationships_31","title":"Relationships","text":"<p>KEY VALUE</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#key","title":"KEY","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nKeyValueExpression--\"KEY\u00b9\"--&gt;KeyValueExpressionKEY[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#value","title":"VALUE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nKeyValueExpression--\"VALUE\u00b9\"--&gt;KeyValueExpressionVALUE[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_31","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#assignexpression","title":"AssignExpression","text":"<p>Labels:Node Statement Expression AssignExpression</p>"},{"location":"CPG/specs/graph/#relationships_32","title":"Relationships","text":"<p>LHS DECLARATIONS RHS</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#lhs_1","title":"LHS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nAssignExpression--\"LHS\u00b9\"--&gt;AssignExpressionLHS[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#declarations","title":"DECLARATIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nAssignExpression--\"DECLARATIONS\u00b9\"--&gt;AssignExpressionDECLARATIONS[&lt;a href='#evariabledeclaration'&gt;VariableDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#rhs_1","title":"RHS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nAssignExpression--\"RHS\u00b9\"--&gt;AssignExpressionRHS[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_32","title":"Properties","text":"<p>usedAsExpression : boolean</p> <p>operatorCode : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#comprehensionexpression","title":"ComprehensionExpression","text":"<p>Labels:Node Statement Expression ComprehensionExpression</p>"},{"location":"CPG/specs/graph/#relationships_33","title":"Relationships","text":"<p>PREDICATE ITERABLE VARIABLE</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#predicate","title":"PREDICATE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nComprehensionExpression--\"PREDICATE\u00b9\"--&gt;ComprehensionExpressionPREDICATE[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#iterable_1","title":"ITERABLE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nComprehensionExpression--\"ITERABLE\u00b9\"--&gt;ComprehensionExpressionITERABLE[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#variable_1","title":"VARIABLE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nComprehensionExpression--\"VARIABLE\u00b9\"--&gt;ComprehensionExpressionVARIABLE[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_33","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#typeexpression","title":"TypeExpression","text":"<p>Labels:Node Statement Expression TypeExpression</p>"},{"location":"CPG/specs/graph/#relationships_34","title":"Relationships","text":"Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_34","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#initializerlistexpression","title":"InitializerListExpression","text":"<p>Labels:Node Statement Expression InitializerListExpression</p>"},{"location":"CPG/specs/graph/#relationships_35","title":"Relationships","text":"<p>INITIALIZERS</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#initializers","title":"INITIALIZERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nInitializerListExpression--\"INITIALIZERS\u00b9\"--&gt;InitializerListExpressionINITIALIZERS[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_35","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#literal","title":"Literal","text":"<p>Labels:Node Statement Expression Literal</p>"},{"location":"CPG/specs/graph/#relationships_36","title":"Relationships","text":"Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_36","title":"Properties","text":"<p>value : Object</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#typeidexpression","title":"TypeIdExpression","text":"<p>Labels:Node Statement Expression TypeIdExpression</p>"},{"location":"CPG/specs/graph/#relationships_37","title":"Relationships","text":"<p>REFERENCED_TYPE</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#referenced_type","title":"REFERENCED_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTypeIdExpression--\"REFERENCED_TYPE\u00b9\"--&gt;TypeIdExpressionREFERENCED_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_37","title":"Properties","text":"<p>operatorCode : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#expressionlist","title":"ExpressionList","text":"<p>Labels:Node Statement Expression ExpressionList</p>"},{"location":"CPG/specs/graph/#relationships_38","title":"Relationships","text":"<p>SUBEXPR</p> Inherited Relationships <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#subexpr","title":"SUBEXPR","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nExpressionList--\"SUBEXPR\u00b9\"--&gt;ExpressionListSUBEXPR[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_38","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#casestatement","title":"CaseStatement","text":"<p>Labels:Node Statement CaseStatement</p>"},{"location":"CPG/specs/graph/#relationships_39","title":"Relationships","text":"<p>CASE_EXPRESSION</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#case_expression","title":"CASE_EXPRESSION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCaseStatement--\"CASE_EXPRESSION\u00b9\"--&gt;CaseStatementCASE_EXPRESSION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_39","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#returnstatement","title":"ReturnStatement","text":"<p>Labels:Node Statement ReturnStatement</p>"},{"location":"CPG/specs/graph/#relationships_40","title":"Relationships","text":"<p>RETURN_VALUES</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#return_values","title":"RETURN_VALUES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nReturnStatement--\"RETURN_VALUES\u00b9\"--&gt;ReturnStatementRETURN_VALUES[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_40","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#labelstatement","title":"LabelStatement","text":"<p>Labels:Node Statement LabelStatement</p>"},{"location":"CPG/specs/graph/#relationships_41","title":"Relationships","text":"<p>SUB_STATEMENT</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#sub_statement","title":"SUB_STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nLabelStatement--\"SUB_STATEMENT\u00b9\"--&gt;LabelStatementSUB_STATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_41","title":"Properties","text":"<p>label : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#emptystatement","title":"EmptyStatement","text":"<p>Labels:Node Statement EmptyStatement</p>"},{"location":"CPG/specs/graph/#relationships_42","title":"Relationships","text":"Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_42","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#ifstatement","title":"IfStatement","text":"<p>Labels:Node Statement IfStatement</p>"},{"location":"CPG/specs/graph/#relationships_43","title":"Relationships","text":"<p>THEN_STATEMENT ELSE_STATEMENT CONDITION_DECLARATION CONDITION INITIALIZER_STATEMENT</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#then_statement","title":"THEN_STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nIfStatement--\"THEN_STATEMENT\u00b9\"--&gt;IfStatementTHEN_STATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#else_statement_1","title":"ELSE_STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nIfStatement--\"ELSE_STATEMENT\u00b9\"--&gt;IfStatementELSE_STATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#condition_declaration_2","title":"CONDITION_DECLARATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nIfStatement--\"CONDITION_DECLARATION\u00b9\"--&gt;IfStatementCONDITION_DECLARATION[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#condition_5","title":"CONDITION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nIfStatement--\"CONDITION\u00b9\"--&gt;IfStatementCONDITION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#initializer_statement_1","title":"INITIALIZER_STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nIfStatement--\"INITIALIZER_STATEMENT\u00b9\"--&gt;IfStatementINITIALIZER_STATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_43","title":"Properties","text":"<p>isConstExpression : boolean</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#catchclause","title":"CatchClause","text":"<p>Labels:Node Statement CatchClause</p>"},{"location":"CPG/specs/graph/#relationships_44","title":"Relationships","text":"<p>BODY PARAMETER</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#body","title":"BODY","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCatchClause--\"BODY\u00b9\"--&gt;CatchClauseBODY[&lt;a href='#eblock'&gt;Block&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#parameter","title":"PARAMETER","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nCatchClause--\"PARAMETER\u00b9\"--&gt;CatchClausePARAMETER[&lt;a href='#evariabledeclaration'&gt;VariableDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_44","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#switchstatement","title":"SwitchStatement","text":"<p>Labels:Node Statement SwitchStatement</p>"},{"location":"CPG/specs/graph/#relationships_45","title":"Relationships","text":"<p>SELECTOR INITIALIZER_STATEMENT STATEMENT SELECTOR_DECLARATION</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#selector","title":"SELECTOR","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSwitchStatement--\"SELECTOR\u00b9\"--&gt;SwitchStatementSELECTOR[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#initializer_statement_2","title":"INITIALIZER_STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSwitchStatement--\"INITIALIZER_STATEMENT\u00b9\"--&gt;SwitchStatementINITIALIZER_STATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#statement_3","title":"STATEMENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSwitchStatement--\"STATEMENT\u00b9\"--&gt;SwitchStatementSTATEMENT[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#selector_declaration","title":"SELECTOR_DECLARATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSwitchStatement--\"SELECTOR_DECLARATION\u00b9\"--&gt;SwitchStatementSELECTOR_DECLARATION[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_45","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#gotostatement","title":"GotoStatement","text":"<p>Labels:Node Statement GotoStatement</p>"},{"location":"CPG/specs/graph/#relationships_46","title":"Relationships","text":"<p>TARGET_LABEL</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#target_label","title":"TARGET_LABEL","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nGotoStatement--\"TARGET_LABEL\u00b9\"--&gt;GotoStatementTARGET_LABEL[&lt;a href='#elabelstatement'&gt;LabelStatement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_46","title":"Properties","text":"<p>labelName : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#continuestatement","title":"ContinueStatement","text":"<p>Labels:Node Statement ContinueStatement</p>"},{"location":"CPG/specs/graph/#relationships_47","title":"Relationships","text":"Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_47","title":"Properties","text":"<p>label : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#defaultstatement","title":"DefaultStatement","text":"<p>Labels:Node Statement DefaultStatement</p>"},{"location":"CPG/specs/graph/#relationships_48","title":"Relationships","text":"Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_48","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#synchronizedstatement","title":"SynchronizedStatement","text":"<p>Labels:Node Statement SynchronizedStatement</p>"},{"location":"CPG/specs/graph/#relationships_49","title":"Relationships","text":"<p>BLOCK EXPRESSION</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#block_1","title":"BLOCK","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSynchronizedStatement--\"BLOCK\u00b9\"--&gt;SynchronizedStatementBLOCK[&lt;a href='#eblock'&gt;Block&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#expression_2","title":"EXPRESSION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSynchronizedStatement--\"EXPRESSION\u00b9\"--&gt;SynchronizedStatementEXPRESSION[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_49","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#trystatement","title":"TryStatement","text":"<p>Labels:Node Statement TryStatement</p>"},{"location":"CPG/specs/graph/#relationships_50","title":"Relationships","text":"<p>RESOURCES ELSE_BLOCK TRY_BLOCK FINALLY_BLOCK CATCH_CLAUSES</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#resources","title":"RESOURCES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTryStatement--\"RESOURCES\u00b9\"--&gt;TryStatementRESOURCES[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#else_block","title":"ELSE_BLOCK","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTryStatement--\"ELSE_BLOCK\u00b9\"--&gt;TryStatementELSE_BLOCK[&lt;a href='#eblock'&gt;Block&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#try_block","title":"TRY_BLOCK","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTryStatement--\"TRY_BLOCK\u00b9\"--&gt;TryStatementTRY_BLOCK[&lt;a href='#eblock'&gt;Block&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#finally_block","title":"FINALLY_BLOCK","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTryStatement--\"FINALLY_BLOCK\u00b9\"--&gt;TryStatementFINALLY_BLOCK[&lt;a href='#eblock'&gt;Block&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#catch_clauses","title":"CATCH_CLAUSES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTryStatement--\"CATCH_CLAUSES\u00b9\"--&gt;TryStatementCATCH_CLAUSES[&lt;a href='#ecatchclause'&gt;CatchClause&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_50","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#breakstatement","title":"BreakStatement","text":"<p>Labels:Node Statement BreakStatement</p>"},{"location":"CPG/specs/graph/#relationships_51","title":"Relationships","text":"Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_51","title":"Properties","text":"<p>label : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#lookupscopestatement","title":"LookupScopeStatement","text":"<p>Labels:Node Statement LookupScopeStatement</p>"},{"location":"CPG/specs/graph/#relationships_52","title":"Relationships","text":"<p>TARGET_SCOPE</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#target_scope","title":"TARGET_SCOPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nLookupScopeStatement--\"TARGET_SCOPE\u00b9\"--&gt;LookupScopeStatementTARGET_SCOPE[&lt;a href='#escope'&gt;Scope&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_52","title":"Properties","text":"<p>symbols : List</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#declarationstatement","title":"DeclarationStatement","text":"<p>Labels:Node Statement DeclarationStatement</p>"},{"location":"CPG/specs/graph/#relationships_53","title":"Relationships","text":"<p>DECLARATIONS</p> Inherited Relationships <p>LOCALS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#declarations_1","title":"DECLARATIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nDeclarationStatement--\"DECLARATIONS\u00b9\"--&gt;DeclarationStatementDECLARATIONS[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_53","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#declaration","title":"Declaration","text":"<p>Labels:Node Declaration</p>"},{"location":"CPG/specs/graph/#children_8","title":"Children","text":"<p>ValueDeclaration TemplateDeclaration NamespaceDeclaration RecordDeclaration TranslationUnitDeclaration ImportDeclaration IncludeDeclaration TypedefDeclaration DeclarationSequence</p>"},{"location":"CPG/specs/graph/#relationships_54","title":"Relationships","text":"Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_54","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#valuedeclaration","title":"ValueDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration</p>"},{"location":"CPG/specs/graph/#children_9","title":"Children","text":"<p>VariableDeclaration EnumConstantDeclaration TypeParameterDeclaration ParameterDeclaration FunctionDeclaration ProblemDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_55","title":"Relationships","text":"<p>ALIASES TYPE ASSIGNED_TYPES USAGE TYPE_OBSERVERS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#aliases_1","title":"ALIASES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nValueDeclaration--\"ALIASES*\"--&gt;ValueDeclarationALIASES[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#type_1","title":"TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nValueDeclaration--\"TYPE\u00b9\"--&gt;ValueDeclarationTYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#assigned_types_1","title":"ASSIGNED_TYPES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nValueDeclaration--\"ASSIGNED_TYPES*\"--&gt;ValueDeclarationASSIGNED_TYPES[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#usage","title":"USAGE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nValueDeclaration--\"USAGE\u00b9\"--&gt;ValueDeclarationUSAGE[&lt;a href='#ereference'&gt;Reference&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#type_observers","title":"TYPE_OBSERVERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nValueDeclaration--\"TYPE_OBSERVERS*\"--&gt;ValueDeclarationTYPE_OBSERVERS[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_55","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#variabledeclaration","title":"VariableDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration VariableDeclaration</p>"},{"location":"CPG/specs/graph/#children_10","title":"Children","text":"<p>TupleDeclaration FieldDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_56","title":"Relationships","text":"<p>INITIALIZER TEMPLATE_PARAMETERS</p> Inherited Relationships <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#initializer_2","title":"INITIALIZER","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nVariableDeclaration--\"INITIALIZER\u00b9\"--&gt;VariableDeclarationINITIALIZER[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#template_parameters_1","title":"TEMPLATE_PARAMETERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nVariableDeclaration--\"TEMPLATE_PARAMETERS\u00b9\"--&gt;VariableDeclarationTEMPLATE_PARAMETERS[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_56","title":"Properties","text":"<p>isImplicitInitializerAllowed : boolean</p> <p>isArray : boolean</p> Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#tupledeclaration","title":"TupleDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration VariableDeclaration TupleDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_57","title":"Relationships","text":"<p>ELEMENT_EDGES</p> Inherited Relationships <p>INITIALIZER</p> <p>TEMPLATE_PARAMETERS</p> <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#element_edges","title":"ELEMENT_EDGES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTupleDeclaration--\"ELEMENT_EDGES\u00b9\"--&gt;TupleDeclarationELEMENT_EDGES[&lt;a href='#evariabledeclaration'&gt;VariableDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_57","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>isImplicitInitializerAllowed : boolean</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>isArray : boolean</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#fielddeclaration","title":"FieldDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration VariableDeclaration FieldDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_58","title":"Relationships","text":"<p>DEFINES</p> Inherited Relationships <p>INITIALIZER</p> <p>TEMPLATE_PARAMETERS</p> <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#defines","title":"DEFINES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFieldDeclaration--\"DEFINES\u00b9\"--&gt;FieldDeclarationDEFINES[&lt;a href='#efielddeclaration'&gt;FieldDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_58","title":"Properties","text":"<p>modifiers : List</p> <p>isDefinition : boolean</p> Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>isImplicitInitializerAllowed : boolean</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>isArray : boolean</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#enumconstantdeclaration","title":"EnumConstantDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration EnumConstantDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_59","title":"Relationships","text":"<p>INITIALIZER</p> Inherited Relationships <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#initializer_3","title":"INITIALIZER","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nEnumConstantDeclaration--\"INITIALIZER\u00b9\"--&gt;EnumConstantDeclarationINITIALIZER[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_59","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#typeparameterdeclaration","title":"TypeParameterDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration TypeParameterDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_60","title":"Relationships","text":"<p>DEFAULT</p> Inherited Relationships <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#default","title":"DEFAULT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTypeParameterDeclaration--\"DEFAULT\u00b9\"--&gt;TypeParameterDeclarationDEFAULT[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_60","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#parameterdeclaration","title":"ParameterDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration ParameterDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_61","title":"Relationships","text":"<p>DEFAULT</p> Inherited Relationships <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#default_1","title":"DEFAULT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nParameterDeclaration--\"DEFAULT\u00b9\"--&gt;ParameterDeclarationDEFAULT[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_61","title":"Properties","text":"<p>modifiers : List</p> <p>isVariadic : boolean</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#functiondeclaration","title":"FunctionDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration FunctionDeclaration</p>"},{"location":"CPG/specs/graph/#children_11","title":"Children","text":"<p>MethodDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_62","title":"Relationships","text":"<p>THROWS_TYPES OVERRIDES BODY DEFINES RETURN_TYPES PARAMETERS</p> Inherited Relationships <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#throws_types","title":"THROWS_TYPES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionDeclaration--\"THROWS_TYPES*\"--&gt;FunctionDeclarationTHROWS_TYPES[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#overrides","title":"OVERRIDES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionDeclaration--\"OVERRIDES*\"--&gt;FunctionDeclarationOVERRIDES[&lt;a href='#efunctiondeclaration'&gt;FunctionDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#body_1","title":"BODY","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionDeclaration--\"BODY\u00b9\"--&gt;FunctionDeclarationBODY[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#defines_1","title":"DEFINES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionDeclaration--\"DEFINES\u00b9\"--&gt;FunctionDeclarationDEFINES[&lt;a href='#efunctiondeclaration'&gt;FunctionDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#return_types","title":"RETURN_TYPES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionDeclaration--\"RETURN_TYPES*\"--&gt;FunctionDeclarationRETURN_TYPES[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#parameters","title":"PARAMETERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionDeclaration--\"PARAMETERS\u00b9\"--&gt;FunctionDeclarationPARAMETERS[&lt;a href='#eparameterdeclaration'&gt;ParameterDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_62","title":"Properties","text":"<p>isDefinition : boolean</p> Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#methoddeclaration","title":"MethodDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration FunctionDeclaration MethodDeclaration</p>"},{"location":"CPG/specs/graph/#children_12","title":"Children","text":"<p>ConstructorDeclaration OperatorDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_63","title":"Relationships","text":"<p>RECORD_DECLARATION RECEIVER</p> Inherited Relationships <p>THROWS_TYPES</p> <p>OVERRIDES</p> <p>BODY</p> <p>DEFINES</p> <p>RETURN_TYPES</p> <p>PARAMETERS</p> <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#record_declaration","title":"RECORD_DECLARATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nMethodDeclaration--\"RECORD_DECLARATION\u00b9\"--&gt;MethodDeclarationRECORD_DECLARATION[&lt;a href='#erecorddeclaration'&gt;RecordDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#receiver","title":"RECEIVER","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nMethodDeclaration--\"RECEIVER\u00b9\"--&gt;MethodDeclarationRECEIVER[&lt;a href='#evariabledeclaration'&gt;VariableDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_63","title":"Properties","text":"<p>isStatic : boolean</p> Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>isDefinition : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#constructordeclaration","title":"ConstructorDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration FunctionDeclaration MethodDeclaration ConstructorDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_64","title":"Relationships","text":"Inherited Relationships <p>RECORD_DECLARATION</p> <p>RECEIVER</p> <p>THROWS_TYPES</p> <p>OVERRIDES</p> <p>BODY</p> <p>DEFINES</p> <p>RETURN_TYPES</p> <p>PARAMETERS</p> <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_64","title":"Properties","text":"Inherited Properties <p>isStatic : boolean</p> <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>isDefinition : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#operatordeclaration","title":"OperatorDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration FunctionDeclaration MethodDeclaration OperatorDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_65","title":"Relationships","text":"Inherited Relationships <p>RECORD_DECLARATION</p> <p>RECEIVER</p> <p>THROWS_TYPES</p> <p>OVERRIDES</p> <p>BODY</p> <p>DEFINES</p> <p>RETURN_TYPES</p> <p>PARAMETERS</p> <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_65","title":"Properties","text":"<p>operatorCode : String</p> <p>isPrefix : boolean</p> <p>isPostfix : boolean</p> Inherited Properties <p>isStatic : boolean</p> <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>isDefinition : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#problemdeclaration","title":"ProblemDeclaration","text":"<p>Labels:Node Declaration ValueDeclaration ProblemDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_66","title":"Relationships","text":"Inherited Relationships <p>ALIASES</p> <p>TYPE</p> <p>ASSIGNED_TYPES</p> <p>USAGE</p> <p>TYPE_OBSERVERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_66","title":"Properties","text":"<p>problem : String</p> <p>problemType : ProblemType</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#templatedeclaration","title":"TemplateDeclaration","text":"<p>Labels:Node Declaration TemplateDeclaration</p>"},{"location":"CPG/specs/graph/#children_13","title":"Children","text":"<p>RecordTemplateDeclaration FunctionTemplateDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_67","title":"Relationships","text":"<p>PARAMETERS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#parameters_1","title":"PARAMETERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTemplateDeclaration--\"PARAMETERS\u00b9\"--&gt;TemplateDeclarationPARAMETERS[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_67","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#recordtemplatedeclaration","title":"RecordTemplateDeclaration","text":"<p>Labels:Node Declaration TemplateDeclaration RecordTemplateDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_68","title":"Relationships","text":"<p>REALIZATION</p> Inherited Relationships <p>PARAMETERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#realization","title":"REALIZATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordTemplateDeclaration--\"REALIZATION\u00b9\"--&gt;RecordTemplateDeclarationREALIZATION[&lt;a href='#erecorddeclaration'&gt;RecordDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_68","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#functiontemplatedeclaration","title":"FunctionTemplateDeclaration","text":"<p>Labels:Node Declaration TemplateDeclaration FunctionTemplateDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_69","title":"Relationships","text":"<p>REALIZATION</p> Inherited Relationships <p>PARAMETERS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#realization_1","title":"REALIZATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionTemplateDeclaration--\"REALIZATION\u00b9\"--&gt;FunctionTemplateDeclarationREALIZATION[&lt;a href='#efunctiondeclaration'&gt;FunctionDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_69","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#namespacedeclaration","title":"NamespaceDeclaration","text":"<p>Labels:Node Declaration NamespaceDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_70","title":"Relationships","text":"<p>DECLARATION_EDGES STATEMENTS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#declaration_edges","title":"DECLARATION_EDGES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNamespaceDeclaration--\"DECLARATION_EDGES\u00b9\"--&gt;NamespaceDeclarationDECLARATION_EDGES[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#statements_1","title":"STATEMENTS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nNamespaceDeclaration--\"STATEMENTS\u00b9\"--&gt;NamespaceDeclarationSTATEMENTS[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_70","title":"Properties","text":"<p>path : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#recorddeclaration","title":"RecordDeclaration","text":"<p>Labels:Node Declaration RecordDeclaration</p>"},{"location":"CPG/specs/graph/#children_14","title":"Children","text":"<p>EnumDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_71","title":"Relationships","text":"<p>IMPORTS CONSTRUCTORS FIELDS TEMPLATES STATIC_IMPORTS RECORDS SUPER_TYPE_DECLARATIONS STATEMENTS METHODS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#imports","title":"IMPORTS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"IMPORTS*\"--&gt;RecordDeclarationIMPORTS[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#constructors","title":"CONSTRUCTORS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"CONSTRUCTORS\u00b9\"--&gt;RecordDeclarationCONSTRUCTORS[&lt;a href='#econstructordeclaration'&gt;ConstructorDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#fields","title":"FIELDS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"FIELDS\u00b9\"--&gt;RecordDeclarationFIELDS[&lt;a href='#efielddeclaration'&gt;FieldDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#templates","title":"TEMPLATES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"TEMPLATES\u00b9\"--&gt;RecordDeclarationTEMPLATES[&lt;a href='#etemplatedeclaration'&gt;TemplateDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#static_imports","title":"STATIC_IMPORTS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"STATIC_IMPORTS*\"--&gt;RecordDeclarationSTATIC_IMPORTS[&lt;a href='#evaluedeclaration'&gt;ValueDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#records","title":"RECORDS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"RECORDS\u00b9\"--&gt;RecordDeclarationRECORDS[&lt;a href='#erecorddeclaration'&gt;RecordDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#super_type_declarations","title":"SUPER_TYPE_DECLARATIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"SUPER_TYPE_DECLARATIONS*\"--&gt;RecordDeclarationSUPER_TYPE_DECLARATIONS[&lt;a href='#erecorddeclaration'&gt;RecordDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#statements_2","title":"STATEMENTS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"STATEMENTS\u00b9\"--&gt;RecordDeclarationSTATEMENTS[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#methods","title":"METHODS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nRecordDeclaration--\"METHODS\u00b9\"--&gt;RecordDeclarationMETHODS[&lt;a href='#emethoddeclaration'&gt;MethodDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_71","title":"Properties","text":"<p>kind : String</p> <p>importStatements : List</p> <p>staticImportStatements : List</p> Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p>"},{"location":"CPG/specs/graph/#enumdeclaration","title":"EnumDeclaration","text":"<p>Labels:Node Declaration RecordDeclaration EnumDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_72","title":"Relationships","text":"<p>ENTRIES</p> Inherited Relationships <p>IMPORTS</p> <p>CONSTRUCTORS</p> <p>FIELDS</p> <p>TEMPLATES</p> <p>STATIC_IMPORTS</p> <p>RECORDS</p> <p>SUPER_TYPE_DECLARATIONS</p> <p>STATEMENTS</p> <p>METHODS</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#entries","title":"ENTRIES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nEnumDeclaration--\"ENTRIES\u00b9\"--&gt;EnumDeclarationENTRIES[&lt;a href='#eenumconstantdeclaration'&gt;EnumConstantDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_72","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>file : String</p> <p>isInferred : boolean</p> <p>kind : String</p> <p>argumentIndex : int</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>importStatements : List</p> <p>staticImportStatements : List</p>"},{"location":"CPG/specs/graph/#translationunitdeclaration","title":"TranslationUnitDeclaration","text":"<p>Labels:Node Declaration TranslationUnitDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_73","title":"Relationships","text":"<p>DECLARATIONS NAMESPACES STATEMENTS INCLUDES</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#declarations_2","title":"DECLARATIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTranslationUnitDeclaration--\"DECLARATIONS\u00b9\"--&gt;TranslationUnitDeclarationDECLARATIONS[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#namespaces","title":"NAMESPACES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTranslationUnitDeclaration--\"NAMESPACES\u00b9\"--&gt;TranslationUnitDeclarationNAMESPACES[&lt;a href='#enamespacedeclaration'&gt;NamespaceDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#statements_3","title":"STATEMENTS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTranslationUnitDeclaration--\"STATEMENTS\u00b9\"--&gt;TranslationUnitDeclarationSTATEMENTS[&lt;a href='#estatement'&gt;Statement&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#includes","title":"INCLUDES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTranslationUnitDeclaration--\"INCLUDES\u00b9\"--&gt;TranslationUnitDeclarationINCLUDES[&lt;a href='#eincludedeclaration'&gt;IncludeDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_73","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#importdeclaration","title":"ImportDeclaration","text":"<p>Labels:Node Declaration ImportDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_74","title":"Relationships","text":"Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_74","title":"Properties","text":"<p>import : Name</p> <p>wildcardImport : boolean</p> <p>alias : Name</p> <p>importURL : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#includedeclaration","title":"IncludeDeclaration","text":"<p>Labels:Node Declaration IncludeDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_75","title":"Relationships","text":"<p>INCLUDES PROBLEMS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#includes_1","title":"INCLUDES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nIncludeDeclaration--\"INCLUDES\u00b9\"--&gt;IncludeDeclarationINCLUDES[&lt;a href='#eincludedeclaration'&gt;IncludeDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#problems","title":"PROBLEMS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nIncludeDeclaration--\"PROBLEMS\u00b9\"--&gt;IncludeDeclarationPROBLEMS[&lt;a href='#eproblemdeclaration'&gt;ProblemDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_75","title":"Properties","text":"<p>filename : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#typedefdeclaration","title":"TypedefDeclaration","text":"<p>Labels:Node Declaration TypedefDeclaration</p>"},{"location":"CPG/specs/graph/#relationships_76","title":"Relationships","text":"<p>TYPE ALIAS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#type_2","title":"TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTypedefDeclaration--\"TYPE\u00b9\"--&gt;TypedefDeclarationTYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#alias","title":"ALIAS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTypedefDeclaration--\"ALIAS\u00b9\"--&gt;TypedefDeclarationALIAS[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_76","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#declarationsequence","title":"DeclarationSequence","text":"<p>Labels:Node Declaration DeclarationSequence</p>"},{"location":"CPG/specs/graph/#relationships_77","title":"Relationships","text":"<p>CHILDREN</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#children_15","title":"CHILDREN","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nDeclarationSequence--\"CHILDREN*\"--&gt;DeclarationSequenceCHILDREN[&lt;a href='#edeclaration'&gt;Declaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_77","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#type_3","title":"Type","text":"<p>Labels:Node Type</p>"},{"location":"CPG/specs/graph/#children_16","title":"Children","text":"<p>ObjectType UnknownType ParameterizedType PointerType AutoType IncompleteType ProblemType FunctionPointerType TupleType ReferenceType FunctionType</p>"},{"location":"CPG/specs/graph/#relationships_78","title":"Relationships","text":"<p>SUPER_TYPE DECLARED_FROM</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#super_type","title":"SUPER_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nType--\"SUPER_TYPE*\"--&gt;TypeSUPER_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#declared_from","title":"DECLARED_FROM","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nType--\"DECLARED_FROM\u00b9\"--&gt;TypeDECLARED_FROM[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_78","title":"Properties","text":"<p>isPrimitive : boolean</p> <p>typeOrigin : Origin</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#objecttype","title":"ObjectType","text":"<p>Labels:Node Type ObjectType</p>"},{"location":"CPG/specs/graph/#children_17","title":"Children","text":"<p>ListType SetType NumericType MapType StringType</p>"},{"location":"CPG/specs/graph/#relationships_79","title":"Relationships","text":"<p>GENERICS RECORD_DECLARATION</p> Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#generics","title":"GENERICS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nObjectType--\"GENERICS*\"--&gt;ObjectTypeGENERICS[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#record_declaration_1","title":"RECORD_DECLARATION","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nObjectType--\"RECORD_DECLARATION\u00b9\"--&gt;ObjectTypeRECORD_DECLARATION[&lt;a href='#erecorddeclaration'&gt;RecordDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_79","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#listtype","title":"ListType","text":"<p>Labels:Node Type ObjectType ListType</p>"},{"location":"CPG/specs/graph/#relationships_80","title":"Relationships","text":"<p>ELEMENT_TYPE</p> Inherited Relationships <p>GENERICS</p> <p>RECORD_DECLARATION</p> <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#element_type","title":"ELEMENT_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nListType--\"ELEMENT_TYPE\u00b9\"--&gt;ListTypeELEMENT_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_80","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#settype","title":"SetType","text":"<p>Labels:Node Type ObjectType SetType</p>"},{"location":"CPG/specs/graph/#relationships_81","title":"Relationships","text":"<p>ELEMENT_TYPE</p> Inherited Relationships <p>GENERICS</p> <p>RECORD_DECLARATION</p> <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#element_type_1","title":"ELEMENT_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nSetType--\"ELEMENT_TYPE\u00b9\"--&gt;SetTypeELEMENT_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_81","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#numerictype","title":"NumericType","text":"<p>Labels:Node Type ObjectType NumericType</p>"},{"location":"CPG/specs/graph/#children_18","title":"Children","text":"<p>IntegerType FloatingPointType BooleanType</p>"},{"location":"CPG/specs/graph/#relationships_82","title":"Relationships","text":"Inherited Relationships <p>GENERICS</p> <p>RECORD_DECLARATION</p> <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_82","title":"Properties","text":"<p>modifier : Modifier</p> <p>bitWidth : Integer</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#integertype","title":"IntegerType","text":"<p>Labels:Node Type ObjectType NumericType IntegerType</p>"},{"location":"CPG/specs/graph/#relationships_83","title":"Relationships","text":"Inherited Relationships <p>GENERICS</p> <p>RECORD_DECLARATION</p> <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_83","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>modifier : Modifier</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>bitWidth : Integer</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#floatingpointtype","title":"FloatingPointType","text":"<p>Labels:Node Type ObjectType NumericType FloatingPointType</p>"},{"location":"CPG/specs/graph/#relationships_84","title":"Relationships","text":"Inherited Relationships <p>GENERICS</p> <p>RECORD_DECLARATION</p> <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_84","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>modifier : Modifier</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>bitWidth : Integer</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#booleantype","title":"BooleanType","text":"<p>Labels:Node Type ObjectType NumericType BooleanType</p>"},{"location":"CPG/specs/graph/#relationships_85","title":"Relationships","text":"Inherited Relationships <p>GENERICS</p> <p>RECORD_DECLARATION</p> <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_85","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>modifier : Modifier</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>bitWidth : Integer</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#maptype","title":"MapType","text":"<p>Labels:Node Type ObjectType MapType</p>"},{"location":"CPG/specs/graph/#relationships_86","title":"Relationships","text":"<p>ELEMENT_TYPE</p> Inherited Relationships <p>GENERICS</p> <p>RECORD_DECLARATION</p> <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#element_type_2","title":"ELEMENT_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nMapType--\"ELEMENT_TYPE\u00b9\"--&gt;MapTypeELEMENT_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_86","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#stringtype","title":"StringType","text":"<p>Labels:Node Type ObjectType StringType</p>"},{"location":"CPG/specs/graph/#relationships_87","title":"Relationships","text":"Inherited Relationships <p>GENERICS</p> <p>RECORD_DECLARATION</p> <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_87","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#unknowntype","title":"UnknownType","text":"<p>Labels:Node Type UnknownType</p>"},{"location":"CPG/specs/graph/#relationships_88","title":"Relationships","text":"Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_88","title":"Properties","text":"<p>typeOrigin : Origin</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#parameterizedtype","title":"ParameterizedType","text":"<p>Labels:Node Type ParameterizedType</p>"},{"location":"CPG/specs/graph/#relationships_89","title":"Relationships","text":"Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_89","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#pointertype","title":"PointerType","text":"<p>Labels:Node Type PointerType</p>"},{"location":"CPG/specs/graph/#relationships_90","title":"Relationships","text":"<p>ELEMENT_TYPE</p> Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#element_type_3","title":"ELEMENT_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nPointerType--\"ELEMENT_TYPE\u00b9\"--&gt;PointerTypeELEMENT_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_90","title":"Properties","text":"<p>pointerOrigin : PointerOrigin</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#autotype","title":"AutoType","text":"<p>Labels:Node Type AutoType</p>"},{"location":"CPG/specs/graph/#relationships_91","title":"Relationships","text":"Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_91","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#incompletetype","title":"IncompleteType","text":"<p>Labels:Node Type IncompleteType</p>"},{"location":"CPG/specs/graph/#relationships_92","title":"Relationships","text":"Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_92","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#problemtype","title":"ProblemType","text":"<p>Labels:Node Type ProblemType</p>"},{"location":"CPG/specs/graph/#relationships_93","title":"Relationships","text":"Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_93","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#functionpointertype","title":"FunctionPointerType","text":"<p>Labels:Node Type FunctionPointerType</p>"},{"location":"CPG/specs/graph/#relationships_94","title":"Relationships","text":"<p>PARAMETERS RETURN_TYPE</p> Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#parameters_2","title":"PARAMETERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionPointerType--\"PARAMETERS*\"--&gt;FunctionPointerTypePARAMETERS[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#return_type","title":"RETURN_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionPointerType--\"RETURN_TYPE\u00b9\"--&gt;FunctionPointerTypeRETURN_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_94","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#tupletype","title":"TupleType","text":"<p>Labels:Node Type TupleType</p>"},{"location":"CPG/specs/graph/#relationships_95","title":"Relationships","text":"<p>TYPES</p> Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#types","title":"TYPES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nTupleType--\"TYPES*\"--&gt;TupleTypeTYPES[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_95","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#referencetype","title":"ReferenceType","text":"<p>Labels:Node Type ReferenceType</p>"},{"location":"CPG/specs/graph/#relationships_96","title":"Relationships","text":"<p>ELEMENT_TYPE</p> Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#element_type_4","title":"ELEMENT_TYPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nReferenceType--\"ELEMENT_TYPE\u00b9\"--&gt;ReferenceTypeELEMENT_TYPE[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_96","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#functiontype","title":"FunctionType","text":"<p>Labels:Node Type FunctionType</p>"},{"location":"CPG/specs/graph/#relationships_97","title":"Relationships","text":"<p>RETURN_TYPES PARAMETERS</p> Inherited Relationships <p>SUPER_TYPE</p> <p>DECLARED_FROM</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#return_types_1","title":"RETURN_TYPES","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionType--\"RETURN_TYPES*\"--&gt;FunctionTypeRETURN_TYPES[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#parameters_3","title":"PARAMETERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nFunctionType--\"PARAMETERS*\"--&gt;FunctionTypePARAMETERS[&lt;a href='#etype'&gt;Type&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_97","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isPrimitive : boolean</p> <p>isInferred : boolean</p> <p>typeOrigin : Origin</p>"},{"location":"CPG/specs/graph/#scope_1","title":"Scope","text":"<p>Labels:Node Scope</p>"},{"location":"CPG/specs/graph/#children_19","title":"Children","text":"<p>ValueDeclarationScope FileScope</p>"},{"location":"CPG/specs/graph/#relationships_98","title":"Relationships","text":"<p>PARENT SCOPE</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#parent","title":"PARENT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nScope--\"PARENT\u00b9\"--&gt;ScopePARENT[&lt;a href='#escope'&gt;Scope&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#scope_2","title":"SCOPE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nScope--\"SCOPE\u00b9\"--&gt;ScopeSCOPE[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_98","title":"Properties","text":"<p>scopedName : String</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#valuedeclarationscope","title":"ValueDeclarationScope","text":"<p>Labels:Node Scope ValueDeclarationScope</p>"},{"location":"CPG/specs/graph/#children_20","title":"Children","text":"<p>FunctionScope StructureDeclarationScope LocalScope</p>"},{"location":"CPG/specs/graph/#relationships_99","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_99","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#functionscope","title":"FunctionScope","text":"<p>Labels:Node Scope ValueDeclarationScope FunctionScope</p>"},{"location":"CPG/specs/graph/#relationships_100","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_100","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#structuredeclarationscope","title":"StructureDeclarationScope","text":"<p>Labels:Node Scope ValueDeclarationScope StructureDeclarationScope</p>"},{"location":"CPG/specs/graph/#children_21","title":"Children","text":"<p>NameScope GlobalScope TemplateScope</p>"},{"location":"CPG/specs/graph/#relationships_101","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_101","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#namescope","title":"NameScope","text":"<p>Labels:Node Scope ValueDeclarationScope StructureDeclarationScope NameScope</p>"},{"location":"CPG/specs/graph/#children_22","title":"Children","text":"<p>NamespaceScope RecordScope</p>"},{"location":"CPG/specs/graph/#relationships_102","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_102","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#namespacescope","title":"NamespaceScope","text":"<p>Labels:Node Scope ValueDeclarationScope StructureDeclarationScope NameScope NamespaceScope</p>"},{"location":"CPG/specs/graph/#relationships_103","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_103","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#recordscope","title":"RecordScope","text":"<p>Labels:Node Scope ValueDeclarationScope StructureDeclarationScope NameScope RecordScope</p>"},{"location":"CPG/specs/graph/#relationships_104","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_104","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#globalscope","title":"GlobalScope","text":"<p>Labels:Node Scope ValueDeclarationScope StructureDeclarationScope GlobalScope</p>"},{"location":"CPG/specs/graph/#relationships_105","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_105","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#templatescope","title":"TemplateScope","text":"<p>Labels:Node Scope ValueDeclarationScope StructureDeclarationScope TemplateScope</p>"},{"location":"CPG/specs/graph/#relationships_106","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_106","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#localscope","title":"LocalScope","text":"<p>Labels:Node Scope ValueDeclarationScope LocalScope</p>"},{"location":"CPG/specs/graph/#relationships_107","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_107","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#filescope","title":"FileScope","text":"<p>Labels:Node Scope FileScope</p>"},{"location":"CPG/specs/graph/#relationships_108","title":"Relationships","text":"Inherited Relationships <p>PARENT</p> <p>SCOPE</p> <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p>"},{"location":"CPG/specs/graph/#properties_108","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>scopedName : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#overlaynode","title":"OverlayNode","text":"<p>Labels:Node OverlayNode</p>"},{"location":"CPG/specs/graph/#children_23","title":"Children","text":"<p>Operation Concept</p>"},{"location":"CPG/specs/graph/#relationships_109","title":"Relationships","text":"Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#properties_109","title":"Properties","text":"<p>underlyingNodeEdge : OverlaySingleEdge</p> Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#operation","title":"Operation","text":"<p>Labels:Node OverlayNode Operation</p>"},{"location":"CPG/specs/graph/#relationships_110","title":"Relationships","text":"<p>CONCEPT</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#concept","title":"CONCEPT","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nOperation--\"CONCEPT\u00b9\"--&gt;OperationCONCEPT[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_110","title":"Properties","text":"Inherited Properties <p>underlyingNodeEdge : OverlaySingleEdge</p> <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#concept_1","title":"Concept","text":"<p>Labels:Node OverlayNode Concept</p>"},{"location":"CPG/specs/graph/#relationships_111","title":"Relationships","text":"<p>OPS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#ops","title":"OPS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nConcept--\"OPS*\"--&gt;ConceptOPS[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_111","title":"Properties","text":"Inherited Properties <p>underlyingNodeEdge : OverlaySingleEdge</p> <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#annotationmember","title":"AnnotationMember","text":"<p>Labels:Node AnnotationMember</p>"},{"location":"CPG/specs/graph/#relationships_112","title":"Relationships","text":"<p>VALUE</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#value_1","title":"VALUE","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nAnnotationMember--\"VALUE\u00b9\"--&gt;AnnotationMemberVALUE[&lt;a href='#eexpression'&gt;Expression&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_112","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#annotation","title":"Annotation","text":"<p>Labels:Node Annotation</p>"},{"location":"CPG/specs/graph/#relationships_113","title":"Relationships","text":"<p>MEMBERS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#members","title":"MEMBERS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nAnnotation--\"MEMBERS*\"--&gt;AnnotationMEMBERS[&lt;a href='#eannotationmember'&gt;AnnotationMember&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_113","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/graph/#component","title":"Component","text":"<p>Labels:Node Component</p>"},{"location":"CPG/specs/graph/#relationships_114","title":"Relationships","text":"<p>TRANSLATION_UNITS INCOMING_INTERACTIONS OUTGOING_INTERACTIONS</p> Inherited Relationships <p>ADDITIONAL_PROBLEMS</p> <p>EOG</p> <p>CDG</p> <p>DFG</p> <p>ANNOTATIONS</p> <p>PDG</p> <p>AST</p> <p>SCOPE</p>"},{"location":"CPG/specs/graph/#translation_units","title":"TRANSLATION_UNITS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nComponent--\"TRANSLATION_UNITS\u00b9\"--&gt;ComponentTRANSLATION_UNITS[&lt;a href='#etranslationunitdeclaration'&gt;TranslationUnitDeclaration&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#incoming_interactions","title":"INCOMING_INTERACTIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nComponent--\"INCOMING_INTERACTIONS*\"--&gt;ComponentINCOMING_INTERACTIONS[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#outgoing_interactions","title":"OUTGOING_INTERACTIONS","text":"<pre><code>flowchart LR\n  classDef outer fill:#fff,stroke:#ddd,stroke-dasharray:5 5;  classDef special fill:#afa,stroke:#5a5,stroke-dasharray:5 5;\nComponent--\"OUTGOING_INTERACTIONS*\"--&gt;ComponentOUTGOING_INTERACTIONS[&lt;a href='#enode'&gt;Node&lt;/a&gt;]:::outer</code></pre>"},{"location":"CPG/specs/graph/#properties_114","title":"Properties","text":"Inherited Properties <p>code : String</p> <p>argumentIndex : int</p> <p>file : String</p> <p>isImplicit : boolean</p> <p>overlayEdges : Overlays</p> <p>fullName : String</p> <p>localName : String</p> <p>name : String</p> <p>nameDelimiter : String</p> <p>comment : String</p> <p>artifact : String</p> <p>startLine : int</p> <p>endLine : int</p> <p>startColumn : int</p> <p>endColumn : int</p> <p>isInferred : boolean</p>"},{"location":"CPG/specs/inference/","title":"Inference System","text":"<p>One of the goals of this library is to deal with incomplete code. In this case, the library provides various options to create new nodes and include them in the resulting graph. The user of the library can configure which of the inference options should be enabled. This document provides an overview of the different options and their expected behavior. The rules for the inferring new nodes are implemented in the class <code>de.fraunhofer.aisec.cpg.passes.inference.Inference</code> and are typically used by various passes.</p>"},{"location":"CPG/specs/inference/#inference-of-namespace-and-record-declarations","title":"Inference of namespace and record declarations","text":"<p>If we encounter a scope, e.g, in a call to a function such as <code>java.lang.Object.toString()</code>, and we do not have a corresponding <code>NameScope</code> for the qualified name <code>java.lang</code>, we try to infer one. We recursively infer a namespace, e.g., <code>java</code> as well as <code>java.lang</code> until the scope can be resolved. There is one special check, in case the name refers to a type. In this case we infer a record declaration instead. This is usually the case when a type is nested in another type, e.g. <code>MyClass::MyIterator::next</code>. If we encounter usage of <code>MyClass::MyIterator</code> as a type somewhere, we infer a record instead of a namespace.</p> <p>Record declarations are indeed inferred for all (object) types that we encounter. The scope of the type or a fully qualified name (if specified) is taken into account when creating an inferred <code>RecordDeclaration</code>. If the record is supposed to exist in a scope / namespace that was \"seen\" (e.g., it was specified as a fully qualified name), but a corresponding <code>NamespaceDeclaration</code> did not exist, we also try to infer this namespace (see above). </p> <p>For example, if we encounter the type <code>java.lang.String</code> (and do not find a matching declaration), we recursively infer the following nodes:</p> <ul> <li><code>NamespaceDeclaration</code> for <code>java</code> in the <code>GlobalScope</code></li> <li><code>NamespaceDeclaration</code> for <code>java.lang</code> in the scope of the inferred <code>java</code>   namespace</li> <li><code>RecordDeclaration</code> for <code>java.lang.String</code> in the scope of the inferred   <code>java.lang</code> namespace</li> </ul> <p>It is sometimes indistinguishable whether we should infer a namespace or a record as a parent scope, since usually languages support nested records or classes. However, we tend to assume that the case that it is a namespace is far more likely.</p>"},{"location":"CPG/specs/inference/#inference-of-function-declarations","title":"Inference of function declarations","text":"<p>If we try to resolve a <code>CallExpression</code>, where no <code>FunctionDeclaration</code> with a matching name and signature exists in the CPG, we infer a new <code>FunctionDeclaration</code>. This may include inferring a receiver (i.e., the base a method is invoked on) for object-oriented programming languages. We also infer the required parameters for this specific call as well as their types.</p> <p>The function declaration must be inferred within the scope of a <code>RecordDeclaration</code>, a <code>NamespaceDeclaration</code> or a <code>TranslationUnitDeclaration</code>. If the function <code>foo</code> is inferred within the scope of a <code>RecordDeclaration</code>, <code>foo</code> may represent a method but it could also be a static import depending on the <code>LanguageTraits</code> of the programming language. If we add a <code>MethodDeclaration</code> to a <code>RecordDeclaration</code> which we treated as a \"struct\", we change its <code>type</code> to \"class\".</p>"},{"location":"CPG/specs/inference/#inference-of-variables","title":"Inference of variables","text":"<p>While we do aim at handling incomplete code, we assume that it is more likely to analyze complete functions and missing some files/dependencies compared to having all files/dependencies available and missing few lines within a file. Based on this assumption, we infer global variables if we cannot find any matching symbol for a reference, but we do NOT infer local variables.</p>"},{"location":"CPG/specs/inference/#inference-of-return-types-of-functions","title":"Inference of return types of functions","text":"<p>This is a rather experimental feature and is therefore disabled by default.</p> <p>This option can be used to guess the return type of an inferred function declaration. We make use of the usage of the returned value (e.g. if it is assigned to a variable/reference, used as an input to a unary or binary operator or as an argument to another function call) and propagate this type to the return type, if it known. One interesting case are unary and binary operators which can be overloaded but we assume that they are more likely to treat numeric values (for <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>++</code>, <code>--</code>) and boolean values (for <code>!</code>).</p>"},{"location":"CPG/specs/inference/#inference-of-dfg-edges","title":"Inference of DFG edges","text":"<p>The library can apply heuristics to infer DFG edges for functions which do not have a body (i.e., functions not implemented in the given source code) if there is no custom specification for the respective function available. All parameters will flow into the return value.</p>"},{"location":"CPG/specs/overlays/","title":"Overlay Graph","text":"<p>The CPG represents the code of a program as a graph of nodes \\(N_{CPG}\\) and edges \\(E\\).</p> <p>Our basic version of the CPG only considers nodes that are part of the CPG's immediate representation of the program's AST (we denote these nodes as \\(N_{AST} \\subseteq N_{CPG}\\)).</p> <p>The edges \\(E\\) represent various graph structures like the abstract syntax tree (AST), data flow graph (DFG), the execution order (EOG), call graph, and further dependencies among code fragments. Each of the edges can have a predefined set of properties which is specified by our graph schema.</p> <p>However, this version of the CPG does not include any information about the semantics of the code or consider expert knowledge on certain framework or libraries.  This is, however, crucial information for in-depth semantic analyses. To account for this, we introduce the concept of an Overlay Graph which allows us to extend the graph with expert knowledge or any other information which may not be directly visible in the code.</p> <p>We define an overlay graph as a set of nodes \\(N_O \\subseteq N_{CPG}\\), where \\(\\forall n_O \\in N_O: n_O \\not\\in N_{AST}\\). This means, we add nodes which are not part of the CPG's AST. These overlay nodes are denoted by extending the interface <code>de.fraunhofer.aisec.cpg.graph.OverlayNode</code> and are connected via an edge to the  nodes in \\(N_{AST}\\). The overlay nodes may have additional edges and can fill  all known except from the AST edge.</p>"},{"location":"CPG/specs/overlays/#concepts-and-operations","title":"Concepts and Operations","text":"<p>One generic extension of the CPG can include concepts and operations for which we provide the two classes <code>de.fraunhofer.aisec.cpg.graph.concepts.Concept</code> and <code>de.fraunhofer.aisec.cpg.graph.concepts.Operation</code> which can be extended. We will incrementally add some nodes to the library within a dedicated module.</p> <p>Each concept aims to represent a certain \"interesting\" type of behavior or somehow relevant information and can contain multiple operations or interesting properties related to the same concept. Operations always have to represent some sort of program behavior.</p> <p>Typically, it makes sense to register custom passes which use the information  provided by the plain version of the CPG and generate new instances of a concept or operation when the pass identifies certain patterns. This pattern may be a call of a specific function, a sequence of functions, it may consider the values passed as arguments, or it may also be a known sequence of operations.</p>"},{"location":"CPG/specs/pdg/","title":"Specification: Program Dependence Graph","text":"<p>The Program Dependence Graph (PDG) is a graph which spans both, the data dependencies and the control dependencies inside the program. This is interesting since it allows to determine which nodes have some kind of effect on another node, let it be due to a (direct) data flow or because they have an impact on the execution of an edge or the potential value. It thus presents a good way to perform program slicing and has traditionally been used in program optimization, among others.</p>"},{"location":"CPG/specs/pdg/#the-pdg-and-implicit-dataflows","title":"The PDG and implicit dataflows","text":"<p>In particular, the PDG is also suitable to identify potential implicit data flows. Consider the following example:</p> <pre><code>import javax.crypto.*;\nclass Main {\n    public static void main(String[] args) {\n        try {\n            KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n            keyGen.init(256); // for example\n            SecretKey secretKey = keyGen.generateKey();\n            boolean b;\n            if(secretKey.getEncoded()[0] == 3) {\n                b = true;\n            } else {\n                b = false;\n            }\n            System.out.println(b);\n        } catch(Exception e) {\n            // We don't care\n        }\n    }\n}\n</code></pre> <p>If you want to know if the key is printed by the program, then you will follow the DFG and you won't find a direct dataflow between the call to <code>generateKey</code> and the call to <code>println</code>.</p> <p>However, if you're wondering if there's some kind of leakage of information about the key, then you will see that the value of the first byte has an effect on the value of the variable <code>b</code> which is printed. This can be interpreted as a data breach and requires you to follow both, the CDG and the DFG or, more conveniently, the PDG.</p> <p>This feature can easily be used through the Query API and Shortcuts by using adding the sensitivity <code>Implicit</code>.</p> <p>As an example, we receive an empty list for when running the following query traversing only the DFG:</p> <pre><code>val dfgOnly =\n    key.followDFGEdgesUntilHit(\n        findAllPossiblePaths = true,\n        direction = Forward(GraphToFollow.DFG),\n        sensitivities = FieldSensitive + ContextSensitive\n    ) {\n        (it as? CallExpression)?.name?.localName == \"println\"\n    }\nprintln(dfgOnly.fulfilled)\n</code></pre> <p>In contrast, we do find the paths between the two nodes when paths when running the same query with <code>Imlicit</code> specifying</p> <pre><code>val pdg =\n    key.followDFGEdgesUntilHit(\n        findAllPossiblePaths = true,\n        direction = Forward(GraphToFollow.DFG),\n        sensitivities = FieldSensitive + ContextSensitive + Implicit\n    ) {\n        (it as? CallExpression)?.name?.localName == \"println\"\n    }\nprintln(pdg.fulfilled)\n</code></pre> <p>Configuration</p> <p>Retrieving the PDG requires to register the two passes <code>ControlDependenceGraphPass</code> and <code>ProgramDependenceGraphPass</code> which are currently not in the list of default passes in the <code>TranslationConfiguration</code>.</p>"},{"location":"Contributing/","title":"Contributing","text":""},{"location":"Contributing/#prerequsites","title":"Prerequsites","text":"<ul> <li>git</li> <li>Java 17 (OpenSDK)</li> </ul>"},{"location":"Contributing/#build-and-run","title":"Build and Run","text":""},{"location":"Contributing/#getting-the-source","title":"Getting the source","text":"<p>First, create a fork of this repository and clone the fork:</p> <pre><code>git clone https://github.com/&lt;&lt;&lt;your-github-account&gt;&gt;&gt;/TODO.git\n</code></pre> <p>Add the upstream repository as a second remote, so you can incorporate upstream changes into your fork:</p> <pre><code>git remote add upstream https://github.com/Fraunhofer-AISEC/cpg.git\n</code></pre>"},{"location":"Contributing/#build","title":"Build","text":"<p>Make sure you can build the repository</p> <pre><code>./gradlew clean spotlessApply build publishToMavenLocal\n</code></pre> <p>This project requires Java 17. If Java 17 is not your default Java version, make sure to configure gradle to use it by setting its java.home variable:</p> <pre><code>./gradlew -Dorg.gradle.java.home=\"/usr/lib/jvm/java-17-openjdk-amd64/\" build\n</code></pre>"},{"location":"Contributing/#copyright-notice","title":"Copyright Notice","text":"<p>This project has the convention of including a license notice header in all source files: <pre><code>/*\n * Copyright (c) 2020, Fraunhofer AISEC. All rights reserved.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *                    $$$$$$\\  $$$$$$$\\   $$$$$$\\\n *                   $$  __$$\\ $$  __$$\\ $$  __$$\\\n *                   $$ /  \\__|$$ |  $$ |$$ /  \\__|\n *                   $$ |      $$$$$$$  |$$ |$$$$\\\n *                   $$ |      $$  ____/ $$ |\\_$$ |\n *                   $$ |  $$\\ $$ |      $$ |  $$ |\n *                   \\$$$$$   |$$ |      \\$$$$$   |\n *                    \\______/ \\__|       \\______/\n *\n */\n</code></pre></p> <p>If you are using IntelliJ IDEA, you can import <code>style/copyright.xml</code> as a copyright profile to automate the header creation process. Click here for further information on copyright profiles.</p>"},{"location":"Contributing/#code-guidelines","title":"Code Guidelines","text":"<p>Most of our code is written in Kotlin and if you develop new nodes, one should follow the following guidelines.</p>"},{"location":"Contributing/#property-edges","title":"Property Edges","text":"<p>On some edges, we want to store additional information (e.g., if a <code>EOG</code> node is \"unreachable\"). In this case, a simple list of nodes for a <code>@Relationship</code> is not enough and instead a list of <code>PropertyEdge</code> objects is needed. To have a consistent naming, the property holding the edges should be named the singular of the property name + \"Edges\", e.g. <code>parameterEdges</code>. To make it more convenient for users to also access the connected nodes without property edges, the Kotlin delegation feature, with a <code>PropertyEdgeDelegate</code> can be used. This property should then be named after the property (plural), e.g. <code>parameters</code>.</p> <pre><code>/** The list of function parameters. */\n@Relationship(value = \"PARAMETERS\", direction = Relationship.Direction.OUTGOING)\n@field:SubGraph(\"AST\")\nvar parameterEdges = mutableListOf&lt;PropertyEdge&lt;ParameterDeclaration&gt;&gt;()\n\n/** Virtual property for accessing [parameterEdges] without property edges. */\nvar parameters by PropertyEdgeDelegate(FunctionDeclaration::parameterEdges)\n</code></pre> <p>Note: We actually want list property to be immutable so that they can only be modified by the node class itself. However, it is currently not possible to have them immutable on the public getter, but mutable for the class itself. There is a Kotlin issue tracking this feature request. Once https://youtrack.jetbrains.com/issue/KT-14663 is resolved, we should set the public type for all those lists to <code>List</code> instead of <code>MutableList</code>. Properties delegated by <code>PropertyEdgeDelegate</code> are already immutable.</p>"},{"location":"Contributing/#required-properties","title":"Required Properties","text":"<p>Properties which can be considered as a required part of an expression, should be non-nullable and be initialized to a <code>ProblemNode</code>. In this case we can represent parsing problems in the graph and still avoid too many null checks. For example in the <code>MemberExpression</code>: <pre><code>var base: Expression = ProblemExpression(\"could not parse base expression\")\n</code></pre></p> <p>There might be cases, where either one or the other property might be required (if a property can either be an <code>Expression</code> or a <code>Declaration</code>, in this case we need to resort of having both properties nullable.</p> <p>Note: In the future, we might move required properties into the constructor of a node. </p>"},{"location":"Contributing/#equals-and-hashcode","title":"<code>equals</code> and <code>hashCode</code>","text":"<p>Because of the special nature of the <code>PropertyEdge</code>, one needs to be careful in comparing them in <code>equals</code>, to avoid stack overflows. Therefore, the special function <code>propertyEqualsList</code> needs to be used: <pre><code>return (super.equals(other) &amp;&amp;\n    parameters == other.parameters &amp;&amp;\n    propertyEqualsList(parameterEdges, other.parameterEdges)\n</code></pre></p> <p><code>hashCode</code> needs to include all properties that are also compared in <code>equals</code>. For easier readability, we should use the Kotlin expression body feature: <pre><code>override fun hashCode() = Objects.hash(super.hashCode(), constructor, arguments)\n</code></pre></p>"},{"location":"Contributing/#pull-requests","title":"Pull Requests","text":"<p>Before we can accept a pull request from you, you'll need to sign a Contributor License Agreement (CLA). It is an automated process and you only need to do it once.</p> <p> We are currently discussing the implementation of a Contributor License Agreement (CLA). Unfortunately, we cannot merge external pull requests until this issue is resolved. </p> <p>To enable us to quickly review and accept your pull requests, always create one pull request per issue and link the issue in the pull request. Never merge multiple requests in one unless they have the same root cause. Be sure your code is formatted correctly using the respective formatting task. Keep code changes as small as possible.  Pull requests should contain tests whenever possible.</p>"},{"location":"Contributing/#change-log","title":"Change-Log","text":"<p>Every PR that changes the graph or interaction with one of the classes that run the analysis has to be documented in the changelog. For this, one should add the appropriated change type (added, changed, removed) under the heading of the thematic change (Graph-changes, Interface-changes). Fixes for specific issues should also be mentioned but their inclusion in the release changelog is optional. An example of a PR-changelog:</p>"},{"location":"Contributing/#graph-changes","title":"Graph-changes","text":""},{"location":"Contributing/#added","title":"Added","text":"<ul> <li>New node <code>A</code> with edges of name <code>B</code> and <code>C</code> to its ast-children.</li> </ul>"},{"location":"Contributing/#changed","title":"Changed","text":"<ul> <li>Property of Node <code>A</code> that describes the name changed from <code>name</code> to <code>simple-name</code>.</li> </ul>"},{"location":"Contributing/#interface-changes","title":"Interface-changes","text":""},{"location":"Contributing/#added_1","title":"Added","text":"<ul> <li>function <code>loadIncludes</code> which persists nodes to the graph comming from in-file includes.</li> </ul>"},{"location":"Contributing/#language","title":"Language","text":"<p>Please stick to English for all discussions and comments. This helps to make the project accessible for a larger audience.</p>"},{"location":"Contributing/#publishing","title":"Publishing","text":"<p>To publish a release, push a tag that contains the version number beginning with <code>v</code>, i.e. <code>v2.0.0</code>. The GitHub Actions workflow will then automatically build a release zip and create a GitHub release. Afterwards it would be good to adjust the release text to include a minimal changelog.</p>"},{"location":"Contributing/#versioning","title":"Versioning","text":"<p>The versioning number is split up in major, minor and bugfix releases: <code>major.minor.bugfix</code>. Most releases will have the form <code>major.minor.0</code>, and bugfixes will be either included in a future version, and the bugfix release number will only be used to ship bug fixes for older versions when necessary.</p>"},{"location":"GettingStarted/","title":"Getting Started","text":"<p>The CPG can be used in different ways:</p> <ul> <li>Using Codyze</li> <li>As a library for Kotlin/Java</li> <li>With custom automated analyses using the Query API</li> <li>Via neo4j</li> </ul> <p>In the first three cases, the Shortcuts provide you a convenient way to quickly explore some of the most relevant information.</p>"},{"location":"GettingStarted/codyze/","title":"Codyze - The swiss army knife for the code property graph","text":"<p>Codyze is a command line tool that allows you to analyze source code using the Code Property Graph (CPG). It is a powerful tool for static analysis, vulnerability detection, and code exploration.</p>"},{"location":"GettingStarted/codyze/#build","title":"Build","text":"<p>Build (and install) a distribution using Gradle</p> <pre><code>./gradlew :codyze:installDist\n</code></pre> <p>Please remember to adjust the <code>gradle.properties</code> before building the project.</p>"},{"location":"GettingStarted/codyze/#usage","title":"Usage","text":"<p>You can then use <code>codyze</code> from the command line by running the installed <code>./codyze/build/install/codyze/bin/codyze</code> binary.</p> <pre><code>Usage: codyze [&lt;options&gt;] &lt;command&gt; [&lt;args&gt;]...\n\nOptions:\n  -h, --help  Show this message and exit\n\nCommands:\n  console\n  compliance  \n</code></pre>"},{"location":"GettingStarted/codyze/#console-command","title":"Console Command","text":"<p>The <code>console</code> command is used to start an interactive console for exploring the CPG. It allows you to explore the code and see the CPG in a more visual way. In the future we will offer a way to run interactive queries in the console.</p> <p> </p>"},{"location":"GettingStarted/codyze/#compliance-command","title":"Compliance Command","text":"<p>The <code>compliance</code> command is used to check compliance with various coding standards and guidelines. It can be used to analyze code for potential vulnerabilities and coding issues. We are currently working on adding more compliance checks and this documentation will be updated accordingly.</p> <p>The <code>compliance</code> command has several subcommands: <pre><code>Usage: codyze compliance [&lt;options&gt;] &lt;command&gt; [&lt;args&gt;]...\n\nOptions:\n  -h, --help  Show this message and exit\n\nCommands:\n  scan\n  list-security-goals\n</code></pre></p> <p>With the most important being the <code>scan</code> command, which is used to scan a project for compliance with the specified security goals.</p> <pre><code>Usage: codyze compliance scan [&lt;options&gt;]\n\nProject Options:\n  --project-dir=&lt;path&gt;  The project directory\n  --console=true|false  Starts the Codyze web console after the analysis\n\nCPG Translation Options:\n  --sources=&lt;path&gt;             A list of source files. They will be all added to a single component 'app'.\n  --components=&lt;text&gt;          The components to analyze. They must be located inside the 'components' folder inside the project directory. The 'components' folder will be taken as the topLevel property for the\n                               translation configuration.\n  --exclusion-patterns=&lt;text&gt;  A pattern of files to exclude\n\nOptions:\n  -h, --help  Show this message and exit\n</code></pre>"},{"location":"GettingStarted/library/","title":"Usage as library","text":"<p>You can use the CPG library in your kotlin project.</p>"},{"location":"GettingStarted/library/#1-add-the-cpg-library-to-your-dependencies","title":"1. Add the CPG library to your dependencies","text":"<p>First, get the required dependencies, e.g. by installing either the whole project or selected submodules from maven central. Here's an excerpt from a <code>build.gradle.kts</code> file: <pre><code>...\nrepositories {\n    mavenCentral()\n    ...\n}\n\ndependencies {\n    implementation(\"de.fraunhofer.aisec:cpg-core:9.0.2\") // The core functionality\n    implementation(\"de.fraunhofer.aisec:cpg-language-java:9.0.2\") // Only the java language frontend\n    ...\n}\n</code></pre></p>"},{"location":"GettingStarted/library/#2-configuring-the-translation","title":"2. Configuring the translation","text":"<p>Before constructing the CPG, you have to configure how you want to translate the code to the CPG. You have to use the <code>TranslationConfiguration</code> and the <code>InferenceConfiguration</code>. It allows you to specify which frontends, and passes you want to use and can steer some analyses. </p> <p>The following lines give you a small example: <pre><code>val inferenceConfig = InferenceConfiguration\n    .builder()\n    .guessCastExpressions(true)\n    .inferRecords(true)\n    .inferDfgForUnresolvedCalls(true)\n    .build()\n\nval translationConfig = TranslationConfiguration\n    .builder()\n    .inferenceConfiguration(inferenceConfig)\n    .defaultPasses()\n    .registerPass&lt;MyCustomPass&gt;()\n    .registerFrontend&lt;MyFrontend&gt;()\n    .sourceLocations(filePaths)\n    .build()\n</code></pre></p> <p>For a complete list of available methods, please check the KDoc.</p> <p>If you want/have to specify data flow summaries for some methods or functions, you add the method <code>registerFunctionSummary</code> when building the <code>TranslationCOnfiguration</code> and add a file with the format specified here</p>"},{"location":"GettingStarted/library/#3-running-the-analysis","title":"3. Running the analysis","text":"<p>Now it's time to get the CPG. All you have to do is to run the analysis with the given configuration. <pre><code>val translationResult = TranslationManager\n    .builder()\n    .config(translationConfig)\n    .build()\n    .analyze()\n    .get()\n</code></pre></p> <p>The CPG is available in the <code>translationResult</code>. You can now run analyses or explore the graph.</p>"},{"location":"GettingStarted/neo4j/","title":"Neo4J visualisation tool for the Code Property Graph","text":"<p>A simple tool to export a code property graph to a neo4j database.</p>"},{"location":"GettingStarted/neo4j/#requirements","title":"Requirements","text":"<p>The application requires Java 17 or higher.</p>"},{"location":"GettingStarted/neo4j/#build","title":"Build","text":"<p>Build (and install) a distribution using Gradle</p> <pre><code>../gradlew installDist\n</code></pre> <p>Please remember to adjust the <code>gradle.properties</code> before building the project.</p>"},{"location":"GettingStarted/neo4j/#usage","title":"Usage","text":"<p><pre><code>./build/install/cpg-neo4j/bin/cpg-neo4j  [--infer-nodes] [--load-includes] [--no-default-passes]\n                    [--no-neo4j] [--no-purge-db] [--print-benchmark]\n                    [--use-unity-build] [--benchmark-json=&lt;benchmarkJson&gt;]\n                    [--custom-pass-list=&lt;customPasses&gt;]\n                    [--export-json=&lt;exportJsonFile&gt;] [--host=&lt;host&gt;]\n                    [--includes-file=&lt;includesFile&gt;]\n                    [--password=&lt;neo4jPassword&gt;] [--port=&lt;port&gt;]\n                    [--save-depth=&lt;depth&gt;] [--top-level=&lt;topLevel&gt;]\n                    [--user=&lt;neo4jUsername&gt;] ([&lt;files&gt;...] | -S=&lt;String=String&gt;\n                    [-S=&lt;String=String&gt;]... |\n                    --json-compilation-database=&lt;jsonCompilationDatabase&gt; |\n                    --list-passes)\n      [&lt;files&gt;...]           The paths to analyze. If module support is\n                               enabled, the paths will be looked at if they\n                               contain modules\n      --benchmark-json=&lt;benchmarkJson&gt;\n                             Save benchmark results to json file\n      --custom-pass-list=&lt;customPasses&gt;\n                             Add custom list of passes (includes\n                               --no-default-passes) which is passed as a\n                               comma-separated list; give either pass name if\n                               pass is in list, or its FQDN (e.g.\n                               --custom-pass-list=DFGPass,CallResolver)\n      --export-json=&lt;exportJsonFile&gt;\n                             Export cpg as json\n      --host=&lt;host&gt;          Set the host of the neo4j Database (default:\n                               localhost).\n      --includes-file=&lt;includesFile&gt;\n                             Load includes from file\n      --infer-nodes          Create inferred nodes for missing declarations\n      --json-compilation-database=&lt;jsonCompilationDatabase&gt;\n                             The path to an optional a JSON compilation database\n      --list-passes          Prints the list available passes\n      --load-includes        Enable TranslationConfiguration option loadIncludes\n      --no-default-passes    Do not register default passes [used for debugging]\n      --no-neo4j             Do not push cpg into neo4j [used for debugging]\n      --no-purge-db          Do no purge neo4j database before pushing the cpg\n      --password=&lt;neo4jPassword&gt;\n                             Neo4j password (default: password\n      --port=&lt;port&gt;          Set the port of the neo4j Database (default: 7687).\n      --print-benchmark      Print benchmark result as markdown table\n  -S, --softwareComponents=&lt;String=String&gt;\n                             Maps the names of software components to their\n                               respective files. The files are separated by\n                               commas (No whitespace!).\n                             Example: -S App1=./file1.c,./file2.c -S App2=.\n                               /Main.java,./Class.java\n      --save-depth=&lt;depth&gt;   Performance optimisation: Limit recursion depth\n                               form neo4j OGM when leaving the AST. -1\n                               (default) means no limit is used.\n      --top-level=&lt;topLevel&gt; Set top level directory of project structure.\n                               Default: Largest common path of all source files\n      --use-unity-build      Enable unity build mode for C++ (requires\n                               --load-includes)\n      --user=&lt;neo4jUsername&gt; Neo4j user name (default: neo4j)\n</code></pre> You can provide a list of paths of arbitrary length that can contain both file paths and directory paths.</p>"},{"location":"GettingStarted/neo4j/#json-export","title":"Json export","text":"<p>It is possible to export the cpg as json file with the <code>--export-json</code> option. The graph is serialized as list of nodes and edges: <pre><code>{\n   \"nodes\": [...],\n   \"edges\": [...]\n}\n</code></pre> Documentation about the graph schema can be found at: https://fraunhofer-aisec.github.io/cpg/CPG/specs/graph</p> <p>Usage example: <pre><code>$ build/install/cpg-neo4j/bin/cpg-neo4j --export-json cpg-export.json --no-neo4j src/test/resources/client.cpp\n</code></pre></p> <p>To export the cpg from a neo4j database, you can use the neo4j <code>apoc</code> plugin. There it's also possible to export only parts of the graph.</p>"},{"location":"GettingStarted/neo4j/#known-issues","title":"Known issues:","text":"<ul> <li> <p>While importing sufficiently large projects with the parameter <code>--save-depth=-1</code>          a <code>java.lang.StackOverflowError</code> may occur.</p> <ul> <li>This error could be solved by increasing the stack size with the JavaVM option: <code>-Xss4m</code></li> <li>Otherwise the depth must be limited (e.g. 3 or 5)</li> </ul> </li> <li> <p>While pushing a constant value larger than 2^63 - 1 a <code>java.lang.IllegalArgumentException</code> occurs.</p> </li> </ul>"},{"location":"GettingStarted/query/","title":"The Query API","text":"<p>The Query API serves as an easy-to-use interface to explore the graph and check if certain properties hold. This allows you to assemble a set of queries that you can use to identify bugs or vulnerabilities in the code under analysis. You can use a number of operations that you know from arithmetics, logics and many programming languages.</p> <p>The Query API provides a way validate if nodes in the graph fulfill certain requirements. It is a mixture of typical logical expressions (e.g. and, or, xor, implies), quantors (e.g. forall, exists), comparisons (e.g. &lt;, &gt;, ==, !=), some special operations (e.g., <code>in</code> to check for collections or <code>is</code> for types) and a couple of operations.</p>"},{"location":"GettingStarted/query/#operation-modes","title":"Operation modes","text":"<p>The Query API has two modes of operations which determine the depth of the output:</p> <ol> <li>The detailed mode reasons about every single step performed to check if the    query is fulfilled.</li> <li>The less detailed mode only provides the final output (true, false) and the    nodes which serve as input.</li> </ol> <p>To use the detailed mode, it is necessary to use specific operators in a textual representation whereas the other modes relies on the operators as known from any programming language.</p> <p>The following example output from the test case <code>testMemcpyTooLargeQuery2</code> shows the difference:</p> <p>Less detailed: <pre><code>[CallExpression[name=memcpy,location=vulnerable.cpp(3:5-3:38),type=UNKNOWN,base=&lt;null&gt;]]\n</code></pre></p> <p>Detailed mode: <pre><code>all (==&gt; false)\n--------\n    Starting at CallExpression[name=memcpy,location=vulnerable.cpp(3:5-3:38),type=UNKNOWN,base=&lt;null&gt;]: 5 &gt; 11 (==&gt; false)\n------------------------\n        sizeof(Reference[Reference[name=array,location=vulnerable.cpp(3:12-3:17),type=PointerType[name=char[]]],refersTo=VariableDeclaration[name=array,location=vulnerable.cpp(2:10-2:28),initializer=Literal[location=vulnerable.cpp(2:21-2:28),type=PointerType[name=char[]],value=hello]]]) (==&gt; 5)\n----------------------------------------\n------------------------\n        sizeof(Literal[location=vulnerable.cpp(3:19-3:32),type=PointerType[name=char[]],value=Hello world]) (==&gt; 11)\n----------------------------------------\n------------------------\n--------\n</code></pre></p>"},{"location":"GettingStarted/query/#operators-of-the-detailed-mode","title":"Operators of the detailed mode","text":"<p>The starting point of an analysis is typically one operation inspired by predicate logics (allExtended or existsEtended) which work as follows:</p> <ul> <li>They allow you to specify which type of nodes serve as starting point via   a reified type parameter.</li> <li>The first argument is a function/lambda which describes certain pre-filtering   requirements for the nodes to check. This can be used to write something like   \"implies\" in the logical sense.</li> <li>The second argument check the condition which has to hold for all or at least   one of these pre-filtered nodes.</li> </ul> <p>Example (the first argument of a call to \"foo\" must be 2):  <pre><code>result.allExtended&lt;CallExpression&gt;{it.name.localName == \"foo\"} {it.argument[0].intValue eq const(2) }\n</code></pre></p> <p>Numerous methods allow to evaluate the queries while keeping track of all the steps. Currently, the following operations are supported:</p> <ul> <li>eq: Equality of two values.</li> <li>ne: Inequality of two values.</li> <li>IN: Checks if a value is contained in a [Collection]</li> <li>IS: Checks if a value implements a type ([Class]).</li> </ul> <p>Additionally, some functions are available only for certain types of values.</p> <p>For boolean values:</p> <ul> <li>and: Logical and operation (&amp;&amp;)</li> <li>or: Logical or operation (||)</li> <li>xor: Logical exclusive or operation (xor)</li> <li>implies: Logical implication</li> </ul> <p>For numeric values:</p> <ul> <li>gt: Grater than (&gt;)</li> <li>ge: Grater than or equal (&gt;=)</li> <li>lt: Less than (&lt;)</li> <li>le: Less than or equal (&lt;=)</li> </ul> <p>Note: The detailed mode and its operators require the user to take care of the correct order. I.e., the user has to put the brackets!</p> <p>For a full list of available methodsm check the dokka documentation pages functions and properties and look for the methods which somehow make use of the <code>QueryTree</code> here.</p>"},{"location":"GettingStarted/query/#operators-of-the-less-detailed-mode","title":"Operators of the less detailed mode","text":"<p>Numerous methods allow to evaluate the queries:</p> <ul> <li>==: Equality of two values.</li> <li>!=: Inequality of two values.</li> <li>in : Checks if a value is contained in a [Collection]. The value of a   query tree has to be accessed by the property <code>value</code>.</li> <li>is: Checks if a value implements a type ([Class]). The value of a query   tree has to be accessed by the property <code>value</code>.</li> <li>&amp;&amp;: Logical and operation</li> <li>||: Logical or operation</li> <li>xor: Logical exclusive or operation</li> <li>&gt;: Grater than</li> <li>&gt;=: Grater than or equal</li> <li>&lt;: Less than</li> <li>&lt;=: Less than or equal</li> </ul>"},{"location":"GettingStarted/query/#functions-of-the-query-api","title":"Functions of the Query API","text":"<p>Since these operators cannot cover all interesting values, we provide an initial set of analyses and functions to use them. These are:</p> <ul> <li>min(n: Node): Minimal value of a node</li> <li>max(n: Node): Maximal value of a node</li> <li>evaluate(evaluator: ValueEvaluator): Evaluates the value of a node. You   can use different evaluators which can affect the possible results. In general,   it makes sense to check if the evaluation succeeded and/or transfer the types.   E.g., the default value evaluator could return different numbers (transferring   them e.g. with <code>toLong()</code> or <code>toFloat()</code> could make sense), a string, or an error.</li> <li>sizeof(n: Node): The length of an array or string</li> <li>dataFlow(startNode: Node, direction: AnalysisDirection, type: AnalysisType, vararg sensitivities: AnalysisSensitivity, scope: AnalysisScope = Interprocedural(), verbose: Boolean, earlyTermination: ((Node) -&gt; Boolean)?, predicate: (Node) -&gt; Boolean):   Checks if a data flow is possible between the nodes <code>from</code> as a source and a   node matching the <code>predicate</code> as sink and has various configuration options:</li> <li>It can be configured as <code>Must</code> or <code>May</code> analysis via the argument <code>type</code>.</li> <li>There are several options for <code>sensitivities</code> which can be used to specify     which requirements you have for the analysis, e.g. <code>FieldSensitive</code>,     <code>ContextSensitive</code>, <code>OnlyFullDFG</code> or <code>Implicit</code>.</li> <li>The <code>scope</code> can be used to configure an <code>Intraprocedural</code> or <code>Interprocedural</code>     analysis or to look up only a certain number of steps or depth in the call     stack.</li> <li><code>earlyTermination</code> lets the query fail early if there was no node matching     <code>predicate</code> on the path so far.</li> <li>executionPath(startNode: Node, direction: AnalysisDirection, type: AnalysisType, vararg sensitivities: AnalysisSensitivity, scope: AnalysisScope = Interprocedural(), verbose: Boolean, earlyTermination: ((Node) -&gt; Boolean)?, predicate: (Node) -&gt; Boolean):   Checks if an execution path is possible between the nodes <code>from</code> as a source   and a node matching the <code>predicate</code> as sink and has various configuration   options which are the same as the ones for <code>dataFlow</code>. However, other options   for <code>sensitivities</code> make more sense in this context.</li> <li>dataFlowWithValidator(source: Node, validatorPredicate: (Node) -&gt; Boolean, sinkPredicate: (Node) -&gt; Boolean, scope: AnalysisScope, vararg sensitivities: AnalysisSensitivity):   Checks if each execution path between the <code>source</code> and a sink matching   <code>sinkPredicate</code> has a node matching <code>validatorPredicate</code>, where the data   in <code>source</code> also flow into <code>validatorPredicate</code>. This is interesting to  \"sanitize\" data on the given path.</li> <li>Node.alwaysFlowsTo(allowOverwritingValue: Boolean, earlyTermination: ((Node) -&gt; Boolean)?, scope: AnalysisScope, vararg sensitivities: AnalysisSensitivity, predicate: (Node) -&gt; Boolean):   Checks if on each execution path starting at <code>source</code>, the data kept in   <code>source</code> reach a sink matching <code>predicate</code> without passing another node   matching <code>earlyTermination</code>.</li> </ul>"},{"location":"GettingStarted/query/#running-a-query","title":"Running a query","text":"<p>The query can use any of these operators and functions and additionally operate on the fields of a node. To simplify the generation of queries, we provide an initial set of extensions for certain nodes.</p> <p>An example for such a query could look as follows for the detailed mode: <pre><code>val memcpyTooLargeQuery = { node: CallExpression -&gt;\n    sizeof(node.arguments[0]) gt sizeof(node.arguments[1])\n}\n</code></pre></p> <p>The same query in the less detailed mode: <pre><code>val memcpyTooLargeQuery = { node: CallExpression -&gt;\n    sizeof(node.arguments[0]) &gt; sizeof(node.arguments[1])\n}\n</code></pre></p> <p>After assembling a query of the respective operators and functions, we want to run it for a subset of nodes in the graph. We therefore provide two operators: <code>all</code> (or <code>allExtended</code> for the detailed output) and <code>exists</code> (or <code>existsExtended</code> for the detailed output). Both are used in a similar way. They enable the user to optionally specify conditions to determine on which nodes we want to run a query (e.g., only on <code>CallExpression</code>s which call a function called \"memcpy\").</p> <p>The following snippets use the queries from above to run them on all calls of the function \"memcpy\" contained in the <code>TranslationResult</code> <code>result</code>: <pre><code>val queryTreeResult =\n    result.allExtended&lt;CallExpression&gt;(\n        { it.name == \"memcpy\" },\n        { sizeof(it.arguments[0]) gt sizeof(it.arguments[1]) }\n    )\n</code></pre></p> <p>Less detailed: <pre><code>val queryTreeResult =\n    result.all&lt;CallExpression&gt;(\n        { it.name == \"memcpy\" },\n        { sizeof(it.arguments[0]) &gt; sizeof(it.arguments[1]) }\n    )\n</code></pre></p>"},{"location":"GettingStarted/query_examples/","title":"Query Examples","text":"<p>We want to create a way to create \"rules\" or \"checks\", that check for certain patterns in the code. Therefore we need to decide, if we want to have a \"algorithmic\" or a \"descriptive\" way to declare such as check.</p> <p>Syntax explanation: <code>|x|</code> means, that <code>x</code> should be \"resolved\", either through constant propagation or other fancy algorithms.</p> <p>The following examples check that no such bug is present.</p>"},{"location":"GettingStarted/query_examples/#array-out-of-bounds-exception","title":"Array out of bounds exception","text":"<p>Part of: CWE 119 <pre><code>result.all&lt;ArraySubscriptionExpression&gt;(mustSatisfy = { max(it.subscriptExpression) &lt; min(it.size) &amp;&amp; min(it.subscriptExpression) &gt;= 0 })\n</code></pre></p>"},{"location":"GettingStarted/query_examples/#null-pointer-dereference-cwe-476","title":"Null pointer dereference (CWE 476)","text":"<pre><code>result.all&lt;HasBase&gt;(mustSatisfy={it.base() != null})\n</code></pre>"},{"location":"GettingStarted/query_examples/#memcpy-too-large-source-buffer-overflow","title":"Memcpy too large source (Buffer Overflow)","text":"<p>Part of CWE 120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') \u2192 do we also need to find selfwritten copy functions for buffers? <pre><code>result.all&lt;CallExpression&gt;({ it.name == \"memcpy\" }, { sizeof(it.arguments[0]) &gt;= min(it.arguments[2]) } )\n</code></pre></p>"},{"location":"GettingStarted/query_examples/#memcpy-too-small-source","title":"Memcpy too small source","text":"<pre><code>result.all&lt;CallExpression&gt;({ it.name == \"memcpy\" }, { sizeof(it.arguments[1]) &lt;= max(it.arguments[2]) } )\n</code></pre>"},{"location":"GettingStarted/query_examples/#division-by-0-cwe-369","title":"Division by 0 (CWE 369)","text":"<pre><code>result.all&lt;BinaryOperator&gt;({ it.operatorCode == \"/\" }, { !(it.rhs.evaluate(MultiValueEvaluator()) as NumberSet).maybe(0) } )\n</code></pre>"},{"location":"GettingStarted/query_examples/#integer-overflowunderflow-cwe-190-191-128","title":"Integer Overflow/Underflow (CWE 190, 191, 128)","text":"<p>For assignments: <pre><code>result.all&lt;Assignment&gt;({ it.target?.type?.isPrimitive == true }, { max(it.value) &lt;= maxSizeOfType(it.target!!.type) &amp;&amp; min(it.value) &gt;= minSizeOfType(it.target!!.type)})\n</code></pre> For other expressions, we need to compute the effect of the operator</p>"},{"location":"GettingStarted/query_examples/#use-after-free","title":"Use after free","text":"<p>Intuition: No node which is reachable from a node <code>free(x)</code> must use <code>x</code>. Use EOG for reachability but I'm not sure how to say \"don't use x\". This is the most basic form. <pre><code>result.all&lt;CallExpression&gt;({ it.name == \"free\" }) { outer -&gt; !executionPath(outer) { (it as? DeclaredReferenceExpression)?.refersTo == (outer.arguments[0] as? DeclaredReferenceExpression)?.refersTo }.value }\n</code></pre></p>"},{"location":"GettingStarted/query_examples/#double-free","title":"Double Free","text":"<pre><code>result.all&lt;CallExpression&gt;({ it.name == \"free\" }) { outer -&gt; !executionPath(outer) { ((it as? CallExpression)?.name == \"free\" &amp;&amp; ((it as? CallExpression)?.arguments?.getOrNull(0) as? DeclaredReferenceExpression)?.refersTo == (outer.arguments[0] as? DeclaredReferenceExpression)?.refersTo }.value }\n</code></pre>"},{"location":"GettingStarted/query_examples/#format-string-attack","title":"Format string attack","text":"<p>arg0 of functions such as <code>printf</code> must not be user input. Since I'm not aware that we have a general model for \"this is user input\" (yet), we could say that all options for the argument must be a Literal (not sure if the proposed notation makes sense though). <pre><code>vuln_fcs = [\"fprint\", \"printf\", \"sprintf\", \"snprintf\", \"vfprintf\", \"vprintf\", \"vsprintf\", \"vsnprintf\"];\nforall (n: CallExpression): n.invokes.name in vuln_fcs =&gt; forall u in |backwards_DFG(n.arguments[0])|: u is Literal\n</code></pre></p> <p>Since many classical vulns. (injection) are related to user input, we probably need a way to specify sources of user input (or \"sources\" in general). To reduce FP, we probably also want to check some conditions over the path between the source and the sink (e.g. some checks are in place to check for critical characters/substrings, do escaping, etc.). Problem: There are tons of options.</p>"},{"location":"GettingStarted/query_examples/#access-of-uninitialized-pointer-cwe-824","title":"Access of Uninitialized Pointer (CWE 824)","text":""},{"location":"GettingStarted/query_examples/#access-of-invalid-memory-address","title":"Access of Invalid Memory Address","text":""},{"location":"GettingStarted/query_examples/#unsecure-default-return-value","title":"Unsecure Default Return Value","text":"<p>Sounds like this always depends on the program? What is an insecure return value?</p> <p>E.g.: *  Authorization: instead of assuming successful authorization (<code>authorized = true</code>) and checking for the contrary; start with assuming unauthorized (<code>authorized = false</code>) and check for authorization</p>"},{"location":"GettingStarted/query_examples/#missing-return-value-validation-error-checking","title":"Missing Return Value Validation (Error checking)","text":"<p>CWE 252</p> <p>I can't think of a simple query here which does not introduce too many findings because it often depends \"what happens afterwards\". Example: logging an error value is typically not problematic. Also, the return values can have very different meanings which makes it hard to find a solution for all issues.</p> <p>Simple idea 1: There has to be at least a check for the return value (probably for a given list of functions and respective error indicating return values).</p>"},{"location":"GettingStarted/query_examples/#command-injection","title":"Command Injection","text":"<ul> <li>Perform data flow analysis and check if unchecked user input reaches function calling system commands</li> </ul>"},{"location":"GettingStarted/query_examples/#proper-nulltermination-of-strings-c-specific","title":"Proper Nulltermination of Strings (C specific)","text":""},{"location":"GettingStarted/query_examples/#improper-certificate-validation-cwe-306","title":"Improper Certificate Validation (CWE 306)","text":"<p>=&gt; Use codyze?</p>"},{"location":"GettingStarted/query_examples/#use-of-hard-coded-credentials-cwe-798","title":"Use of Hard-coded Credentials (CWE 798)","text":"<p>Idea: when crypto API is known, we could follow to input argument for passwords / keys ...</p> <pre><code>relevant_args = {\"function\": \"arg0\"}\nforall (n: CallExpression): n.invokes.name in relevant_args.keys =&gt; forall u in |backwards_DFG(relevant_args(n.invokes.name))|: u !is Literal\n</code></pre>"},{"location":"GettingStarted/query_examples/#scribbles","title":"Scribbles","text":""},{"location":"GettingStarted/query_examples/#test-arguments-of-call-expression","title":"Test arguments of call expression","text":"<pre><code>result.all&lt;CallExpression&gt;({ it.name == \"&lt;function name&gt;\" }) { it.arguments[&lt;no.&gt;].value!! == const(&lt;value&gt;) }\n</code></pre>"},{"location":"GettingStarted/query_examples/#track-return-value-of-call-expression","title":"Track return value of call expression","text":"<pre><code>forall (n1: CallExpression, n2: CallExpression): n1.invokes.name == \"&lt;function name 1&gt;\" &amp;&amp; n2.invokes.name == \"&lt;function name 2&gt;\" =&gt; data_flow(n1.returnValue, n2.arguments[&lt;no.&gt;])\n</code></pre>"},{"location":"GettingStarted/query_examples/#ensure-path-property","title":"Ensure path property","text":"<pre><code>forall (n: CallExpression, v: Value) : n.invokes.name == \"&lt;function name&gt;\" &amp;&amp; data_flow(v, n.arguments[&lt;no.&gt;]) =&gt; inferred_property(v, &lt;property&gt;)\n</code></pre> <p>Example: <pre><code>val algo = read_from_file(/* some file */);\nif (val != \"AES\") {\n  throw Exception();\n}\nval cipher = initialize_cipher(algo); // at this point one can infer that algo must have the value \"AES\"\n</code></pre></p>"},{"location":"GettingStarted/query_examples/#httpscwemitreorgdatadefinitions1228html","title":"https://cwe.mitre.org/data/definitions/1228.html","text":"<p>Should be easy by simply maintaining a list of the dangerous, inconsistent, obsolete, etc. functions and checking all <code>CallExpression</code>s</p>"},{"location":"GettingStarted/query_examples/#which-analyses-do-we-need","title":"Which analyses do we need?","text":"<ul> <li>Integer range</li> <li>Buffer size of constant sized arrays (mem size, no elements)</li> <li>Data flow analysis (intraproc: DFG edges, interproc: missing)</li> <li>Reachability (intraproc: EOG edges, interproc: missing)</li> <li>Points-to information</li> <li>Taint analysis</li> <li>Constant propagation</li> </ul>"},{"location":"GettingStarted/shortcuts/","title":"Shortcuts to Explore the Graph","text":"<p>When analyzing software, there are some information which are interesting to explore. To facilitate accessing the information even without in-depth knowledge about the graph and the graph model, we provide a number of shortcuts which can be used on all nodes to find the nodes you're looking for.</p> <p>All you have to do to use this functionality is to add the <code>import de.fraunhofer.aisec.cpg.graph.*</code>.</p>"},{"location":"GettingStarted/shortcuts/#ast-subtree-traversal","title":"AST subtree traversal","text":"<p>It is often useful to find nodes which are in the AST subtree of another node. We provide the following shortcuts to gain a quick overview of relevant types of nodes:</p> <p>Starting from node <code>n</code>...</p> <ul> <li>...get all function/method calls with <code>n.calls</code></li> <li>...get all member calls (i.e., calls which are called on an object or class)   with <code>n.mcalls</code></li> <li>...get all method declarations with <code>n.methods</code></li> <li>...get all function (and method) declarations with <code>n.functions</code></li> <li>...get all field declarations with <code>n.fields</code></li> <li>...get all parameters with <code>n.parameters</code></li> <li>...get all record declarations (e.g. classes, structs) with <code>n.records</code></li> <li>...get all namespaces with <code>n.namespaces</code></li> <li>...get all variables with <code>n.variables</code></li> <li>...get all literals with <code>n.literals</code></li> <li>...get all references to variables, fields, functions, etc. with <code>n.refs</code></li> <li>...get all assignments with <code>n.assignments</code></li> </ul>"},{"location":"GettingStarted/shortcuts/#filtering-the-results","title":"Filtering the results","text":"<p>The lists you get here can be quite long, and it's a good idea to filter them. To do so, we provide different operators:</p> <ul> <li>To retrieve a single element, you can use the <code>[]</code> (get) operator and specify   your criterion inside the brackets.</li> <li>To retrieve a single element and get an exception if there are multiple   options, add the <code>SearchModifiers.UNIQUE</code> to the query.</li> <li>To retrieve a list of nodes, you can use the <code>()</code> (invokes) operator to   specify your criterion.</li> </ul> <p>Both notations allow you to quickly filter for the name by providing the respective string or by accessing the fields and writing conditions on them.</p> <p>Examples: <pre><code>import de.fraunhofer.aisec.cpg.graph.*\n\n// returns the first variable in the graph which has the name \"a\"\nvar a = result.variables[\"a\"]\n\n// returns the only variable with the name \"a\" or an exception otherwise\nvar theOnlyA = result.variables[\"a\", SearchModifiers.UNIQUE]\n\n// returns the first variable in the graph which does have an initializer\nvar anyWithInitializer = result.variables[{ it.initializer != null }]\n\n// returns the only variable in the graph which does not have an initializer or throws an exception\nvar uniqueWithInitializer = result.variables[{ it.initializer != null }, SearchModifiers.UNIQUE]\n\n// returns a list of all VariableDeclarations in the graph with the name \"a\"\nvar aList = result.variables(\"a\")\n\n// returns a list of FunctionDeclarations that have no parameter\nvar noArgs = result.functions { it.parameters.isEmpty() }\n</code></pre></p>"},{"location":"GettingStarted/shortcuts/#more-information-needed","title":"More information needed?","text":"<p>In some cases, the AST-based traversals won't suffice to filter the nodes that you're interested in. For this reason, there are a number of additional methods which search for other patterns in the graph. Note that these are often less stable than the information from above!</p> <ul> <li>The size of an array is evaluated using   <code>SubscriptExpression.arraySize</code>. Unfortunately, this only works if the   size is given in the initialization. Updates are not considered.</li> <li>Control dependencies are currently available via the extensions   <code>Node.controlledBy()</code> and <code>IfStatement.controls()</code>.</li> <li><code>Node.eogDistanceTo(to: Node)</code> calculates the number of EOG edges between    this node and <code>to</code>.</li> <li><code>FunctionDeclaration.get(n: Int)</code>: Returns the n-th statement of the body of   this function.</li> <li><code>FunctionDeclaration.callees</code>: Returns the functions which are called from   this function.</li> <li><code>TranslationResult.callersOf(function: FunctionDeclaration)</code> determines which   functions call the specified function.</li> <li>The methods   <pre><code>Node.followEOGEdgesUntilHit(\n    collectFailedPaths: Boolean,\n    findAllPossiblePaths: Boolean,\n    direction: AnalysisDirection,\n    vararg sensitivities: AnalysisSensitivity,\n    scope: AnalysisScope,\n    earlyTermination: (Node, Context) -&gt; Boolean,\n    predicate: (Node) -&gt; Boolean\n): FulfilledAndFailedPaths\n</code></pre>   and   <pre><code>Node.followDFGEdgesUntilHit(\n    collectFailedPaths: Boolean,\n    findAllPossiblePaths: Boolean,\n    direction: AnalysisDirection,\n    vararg sensitivities: AnalysisSensitivity,\n    scope: AnalysisScope,\n    earlyTermination: (Node, Context) -&gt; Boolean,\n    predicate: (Node) -&gt; Boolean\n): FulfilledAndFailedPaths\n</code></pre>   enable you a fine-grained configuration of how to collect EOG or DFG paths   between the node and the first node matching the <code>predicate</code> unless  there is   a node matching the <code>earlyTermination</code> criterion on the path.</li> <li>The <code>scope</code> allows to choose between an intraprocedural and interprocedural     analysis and to configure the number of steps or depth in the call chain to     follow.</li> <li>The methods can further be configured to collect failed paths (to see path     exists which does not fulfill a flow requirement) or to identify all     possible paths reaching the predicate.</li> <li>By default, they are configured to run a <code>Forward</code> analysis, but you can     equally opt for a <code>Backward</code> analysis by setting the <code>direction</code>     accordingly.</li> <li>The <code>sensitivities</code> allow you to filter which edges should be followed.     These are partially based on typical sensitivities for dataflow     analysis(<code>ContextSensitive</code>, <code>FieldSensitive</code>), but actually allow a wider     range of filters, e.g. to only follow full DFG edges, reachable EOG paths,     or even configure the whole analysis system to follow implicit dataflows by     following the program dependence graph.</li> <li>They return all failed and all fulfilled  paths. This allows reasoning more     precisely about the program's behavior.</li> <li>The methods  <code>Node.followPrevCDGEdgesUntilHit(collectFailedPaths: Boolean, findAllPossiblePaths: Boolean, interproceduralAnalysis: Boolean, predicate: (Node) -&gt; Boolean)</code>,  <code>Node.followNextCDGEdgesUntilHit(collectFailedPaths: Boolean, findAllPossiblePaths: Boolean, interproceduralAnalysis: Boolean, predicate: (Node) -&gt; Boolean)</code>,  <code>Node.followPrevPDGEdgesUntilHit(collectFailedPaths: Boolean, findAllPossiblePaths: Boolean, interproceduralAnalysis: Boolean, predicate: (Node) -&gt; Boolean)</code>,  <code>Node.followNextPDGEdgesUntilHit(collectFailedPaths: Boolean, findAllPossiblePaths: Boolean, interproceduralAnalysis: Boolean, predicate: (Node) -&gt; Boolean)</code>,   collect the CDG/PDG path between the node and the first node   matching the predicate. The methods can be configured to collect failed   paths (to see if a path exists which does not fulfill a   requirement), to identify all possible paths reaching a predicate and   partially follow calls as well. They return all failed and all fulfilled   paths. This allows reasoning more precisely about the program's behavior.</li> <li>If you're interested in all nodes reachable via one of the sub-graphs from   a certain node, the methods   <code>Node.collectAllPrevFullDFGPaths()</code>,   <code>Node.collectAllNextFullDFGPaths()</code>,   <code>Node.collectAllPrevEOGPaths()</code>,   <code>Node.collectAllNextEOGPaths()</code>,   <code>Node.collectAllPrevCDGPaths(interproceduralAnalysis: Boolean)</code>,   <code>Node.collectAllNextCDGPaths(interproceduralAnalysis: Boolean)</code>,   <code>Node.collectAllPrevPDGPaths(interproceduralAnalysis: Boolean)</code>,   <code>Node.collectAllNextPDGPaths(interproceduralAnalysis: Boolean)</code>   can be used.</li> </ul>"}]}